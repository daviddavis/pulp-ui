/* tslint:disable */
/* eslint-disable */
/**
 * Pulp 3 API
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * The version of the OpenAPI document: v3
 * Contact: pulp-list@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Serializer for AccessPolicy.
 * @export
 * @interface AccessPolicy
 */
export interface AccessPolicy {
    /**
     * List of callables that define the new permissions to be created for new objects.
     * @type {Array<object>}
     * @memberof AccessPolicy
     */
    permissions_assignment: Array<object>;
    /**
     * List of policy statements defining the policy.
     * @type {Array<object>}
     * @memberof AccessPolicy
     */
    statements: Array<object>;
}
/**
 * Serializer for AccessPolicy.
 * @export
 * @interface AccessPolicyResponse
 */
export interface AccessPolicyResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessPolicyResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof AccessPolicyResponse
     */
    pulp_created?: string;
    /**
     * List of callables that define the new permissions to be created for new objects.
     * @type {Array<object>}
     * @memberof AccessPolicyResponse
     */
    permissions_assignment: Array<object>;
    /**
     * List of policy statements defining the policy.
     * @type {Array<object>}
     * @memberof AccessPolicyResponse
     */
    statements: Array<object>;
    /**
     * The name of ViewSet this AccessPolicy authorizes.
     * @type {string}
     * @memberof AccessPolicyResponse
     */
    viewset_name?: string;
    /**
     * True if the AccessPolicy has been user-modified. False otherwise.
     * @type {boolean}
     * @memberof AccessPolicyResponse
     */
    customized?: boolean;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ArtifactResponse
 */
export interface ArtifactResponse {
    /**
     * 
     * @type {string}
     * @memberof ArtifactResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ArtifactResponse
     */
    pulp_created?: string;
    /**
     * The stored file.
     * @type {string}
     * @memberof ArtifactResponse
     */
    file: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof ArtifactResponse
     */
    size?: number;
    /**
     * The MD5 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    md5?: string | null;
    /**
     * The SHA-1 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha1?: string | null;
    /**
     * The SHA-224 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha224?: string | null;
    /**
     * The SHA-256 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha256?: string | null;
    /**
     * The SHA-384 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha384?: string | null;
    /**
     * The SHA-512 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha512?: string | null;
}
/**
 * Serializer for asynchronous operations.
 * @export
 * @interface AsyncOperationResponse
 */
export interface AsyncOperationResponse {
    /**
     * The href of the task.
     * @type {string}
     * @memberof AsyncOperationResponse
     */
    task: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ContentAppStatusResponse
 */
export interface ContentAppStatusResponse {
    /**
     * The name of the worker.
     * @type {string}
     * @memberof ContentAppStatusResponse
     */
    name?: string;
    /**
     * Timestamp of the last time the worker talked to the service.
     * @type {string}
     * @memberof ContentAppStatusResponse
     */
    last_heartbeat?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ContentGuardResponse
 */
export interface ContentGuardResponse {
    /**
     * 
     * @type {string}
     * @memberof ContentGuardResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ContentGuardResponse
     */
    pulp_created?: string;
    /**
     * The unique name.
     * @type {string}
     * @memberof ContentGuardResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof ContentGuardResponse
     */
    description?: string | null;
}
/**
 * Serializer for the database connection information
 * @export
 * @interface DatabaseConnectionResponse
 */
export interface DatabaseConnectionResponse {
    /**
     * Info about whether the app can connect to the database
     * @type {boolean}
     * @memberof DatabaseConnectionResponse
     */
    connected: boolean;
}
/**
 * Results from evaluating a proposed parameter to a PulpImport call.
 * @export
 * @interface EvaluationResponse
 */
export interface EvaluationResponse {
    /**
     * Parameter value being evaluated.
     * @type {string}
     * @memberof EvaluationResponse
     */
    context: string;
    /**
     * True if evaluation passed, false otherwise.
     * @type {boolean}
     * @memberof EvaluationResponse
     */
    is_valid: boolean;
    /**
     * Messages describing results of all evaluations done. May be an empty list.
     * @type {Array<string>}
     * @memberof EvaluationResponse
     */
    messages: Array<string>;
}
/**
 * Serializer for Group.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Name
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface GroupProgressReportResponse
 */
export interface GroupProgressReportResponse {
    /**
     * The message shown to the user for the group progress report.
     * @type {string}
     * @memberof GroupProgressReportResponse
     */
    message?: string;
    /**
     * Identifies the type of group progress report\'.
     * @type {string}
     * @memberof GroupProgressReportResponse
     */
    code?: string;
    /**
     * The total count of items.
     * @type {number}
     * @memberof GroupProgressReportResponse
     */
    total?: number;
    /**
     * The count of items already processed. Defaults to 0.
     * @type {number}
     * @memberof GroupProgressReportResponse
     */
    done?: number;
    /**
     * The suffix to be shown with the group progress report.
     * @type {string}
     * @memberof GroupProgressReportResponse
     */
    suffix?: string | null;
}
/**
 * Serializer for Group.
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * Name
     * @type {string}
     * @memberof GroupResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    pulp_href?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupResponse
     */
    id?: number;
}
/**
 * Serializer for Users that belong to a Group.
 * @export
 * @interface GroupUser
 */
export interface GroupUser {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof GroupUser
     */
    username: string;
}
/**
 * Serializer for Users that belong to a Group.
 * @export
 * @interface GroupUserResponse
 */
export interface GroupUserResponse {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof GroupUserResponse
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof GroupUserResponse
     */
    pulp_href?: string;
}
/**
 * Serializer for Imports.
 * @export
 * @interface ImportResponse
 */
export interface ImportResponse {
    /**
     * 
     * @type {string}
     * @memberof ImportResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ImportResponse
     */
    pulp_created?: string;
    /**
     * A URI of the Task that ran the Import.
     * @type {string}
     * @memberof ImportResponse
     */
    task: string;
    /**
     * Any parameters that were used to create the import.
     * @type {object}
     * @memberof ImportResponse
     */
    params: object;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface MultipleArtifactContentResponse
 */
export interface MultipleArtifactContentResponse {
    /**
     * 
     * @type {string}
     * @memberof MultipleArtifactContentResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof MultipleArtifactContentResponse
     */
    pulp_created?: string;
    /**
     * A dict mapping relative paths inside the Content to the correspondingArtifact URLs. E.g.: {\'relative/path\': \'/artifacts/1/\'
     * @type {object}
     * @memberof MultipleArtifactContentResponse
     */
    artifacts: object;
}
/**
 * 
 * @export
 * @interface PaginatedAccessPolicyResponseList
 */
export interface PaginatedAccessPolicyResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAccessPolicyResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAccessPolicyResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAccessPolicyResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<AccessPolicyResponse>}
     * @memberof PaginatedAccessPolicyResponseList
     */
    results?: Array<AccessPolicyResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedArtifactResponseList
 */
export interface PaginatedArtifactResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedArtifactResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArtifactResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArtifactResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ArtifactResponse>}
     * @memberof PaginatedArtifactResponseList
     */
    results?: Array<ArtifactResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContentGuardResponseList
 */
export interface PaginatedContentGuardResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedContentGuardResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContentGuardResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContentGuardResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ContentGuardResponse>}
     * @memberof PaginatedContentGuardResponseList
     */
    results?: Array<ContentGuardResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedGroupResponseList
 */
export interface PaginatedGroupResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGroupResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<GroupResponse>}
     * @memberof PaginatedGroupResponseList
     */
    results?: Array<GroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedGroupUserResponseList
 */
export interface PaginatedGroupUserResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGroupUserResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupUserResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupUserResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<GroupUserResponse>}
     * @memberof PaginatedGroupUserResponseList
     */
    results?: Array<GroupUserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedImportResponseList
 */
export interface PaginatedImportResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedImportResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportResponse>}
     * @memberof PaginatedImportResponseList
     */
    results?: Array<ImportResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedMultipleArtifactContentResponseList
 */
export interface PaginatedMultipleArtifactContentResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MultipleArtifactContentResponse>}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    results?: Array<MultipleArtifactContentResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPermissionResponseList
 */
export interface PaginatedPermissionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPermissionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPermissionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPermissionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PermissionResponse>}
     * @memberof PaginatedPermissionResponseList
     */
    results?: Array<PermissionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPulpExportResponseList
 */
export interface PaginatedPulpExportResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPulpExportResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExportResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExportResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PulpExportResponse>}
     * @memberof PaginatedPulpExportResponseList
     */
    results?: Array<PulpExportResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPulpExporterResponseList
 */
export interface PaginatedPulpExporterResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPulpExporterResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExporterResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExporterResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PulpExporterResponse>}
     * @memberof PaginatedPulpExporterResponseList
     */
    results?: Array<PulpExporterResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPulpImporterResponseList
 */
export interface PaginatedPulpImporterResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPulpImporterResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpImporterResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpImporterResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PulpImporterResponse>}
     * @memberof PaginatedPulpImporterResponseList
     */
    results?: Array<PulpImporterResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedRepositoryResponseList
 */
export interface PaginatedRepositoryResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRepositoryResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RepositoryResponse>}
     * @memberof PaginatedRepositoryResponseList
     */
    results?: Array<RepositoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedSigningServiceResponseList
 */
export interface PaginatedSigningServiceResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSigningServiceResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSigningServiceResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSigningServiceResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SigningServiceResponse>}
     * @memberof PaginatedSigningServiceResponseList
     */
    results?: Array<SigningServiceResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTaskGroupResponseList
 */
export interface PaginatedTaskGroupResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTaskGroupResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskGroupResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskGroupResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TaskGroupResponse>}
     * @memberof PaginatedTaskGroupResponseList
     */
    results?: Array<TaskGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTaskResponseList
 */
export interface PaginatedTaskResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTaskResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TaskResponse>}
     * @memberof PaginatedTaskResponseList
     */
    results?: Array<TaskResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUploadResponseList
 */
export interface PaginatedUploadResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUploadResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUploadResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUploadResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UploadResponse>}
     * @memberof PaginatedUploadResponseList
     */
    results?: Array<UploadResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUserResponseList
 */
export interface PaginatedUserResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponseList
     */
    results?: Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedWorkerResponseList
 */
export interface PaginatedWorkerResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedWorkerResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWorkerResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWorkerResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<WorkerResponse>}
     * @memberof PaginatedWorkerResponseList
     */
    results?: Array<WorkerResponse>;
}
/**
 * Serializer for AccessPolicy.
 * @export
 * @interface PatchedAccessPolicy
 */
export interface PatchedAccessPolicy {
    /**
     * List of callables that define the new permissions to be created for new objects.
     * @type {Array<object>}
     * @memberof PatchedAccessPolicy
     */
    permissions_assignment?: Array<object>;
    /**
     * List of policy statements defining the policy.
     * @type {Array<object>}
     * @memberof PatchedAccessPolicy
     */
    statements?: Array<object>;
}
/**
 * Serializer for Group.
 * @export
 * @interface PatchedGroup
 */
export interface PatchedGroup {
    /**
     * Name
     * @type {string}
     * @memberof PatchedGroup
     */
    name?: string;
}
/**
 * Serializer for pulp exporters.
 * @export
 * @interface PatchedPulpExporter
 */
export interface PatchedPulpExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PatchedPulpExporter
     */
    name?: string;
    /**
     * File system directory to store exported tar.gzs.
     * @type {string}
     * @memberof PatchedPulpExporter
     */
    path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedPulpExporter
     */
    repositories?: Array<string>;
    /**
     * Last attempted export for this PulpExporter
     * @type {string}
     * @memberof PatchedPulpExporter
     */
    last_export?: string | null;
}
/**
 * Serializer for PulpImporters.
 * @export
 * @interface PatchedPulpImporter
 */
export interface PatchedPulpImporter {
    /**
     * Unique name of the Importer.
     * @type {string}
     * @memberof PatchedPulpImporter
     */
    name?: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {object}
     * @memberof PatchedPulpImporter
     */
    repo_mapping?: object;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface PatchedTaskCancel
 */
export interface PatchedTaskCancel {
    /**
     * The desired state of the task. Only \'canceled\' is accepted.
     * @type {string}
     * @memberof PatchedTaskCancel
     */
    state?: string;
}
/**
 * Serializer for User/Group object permission.
 * @export
 * @interface PermissionResponse
 */
export interface PermissionResponse {
    /**
     * 
     * @type {string}
     * @memberof PermissionResponse
     */
    pulp_href?: string;
    /**
     * 
     * @type {number}
     * @memberof PermissionResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionResponse
     */
    permission?: string;
    /**
     * Content object.
     * @type {string}
     * @memberof PermissionResponse
     */
    obj?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ProgressReportResponse
 */
export interface ProgressReportResponse {
    /**
     * The message shown to the user for the progress report.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    message?: string;
    /**
     * Identifies the type of progress report\'.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    code?: string;
    /**
     * The current state of the progress report. The possible values are: \'waiting\', \'skipped\', \'running\', \'completed\', \'failed\' and \'canceled\'. The default is \'waiting\'.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    state?: string;
    /**
     * The total count of items.
     * @type {number}
     * @memberof ProgressReportResponse
     */
    total?: number;
    /**
     * The count of items already processed. Defaults to 0.
     * @type {number}
     * @memberof ProgressReportResponse
     */
    done?: number;
    /**
     * The suffix to be shown with the progress report.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    suffix?: string | null;
}
/**
 * Serializer for PulpExports.
 * @export
 * @interface PulpExport
 */
export interface PulpExport {
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof PulpExport
     */
    task?: string | null;
    /**
     * Do a Full (true) or Incremental (false) export.
     * @type {boolean}
     * @memberof PulpExport
     */
    full?: boolean;
    /**
     * Generate report on what would be exported and disk-space required.
     * @type {boolean}
     * @memberof PulpExport
     */
    dry_run?: boolean;
    /**
     * List of explicit repo-version hrefs to export (replaces current_version).
     * @type {Array<string>}
     * @memberof PulpExport
     */
    versions?: Array<string>;
    /**
     * Chunk export-tarfile into pieces of chunk_size bytes.Recognizes units of B/KB/MB/GB/TB.
     * @type {string}
     * @memberof PulpExport
     */
    chunk_size?: string;
    /**
     * List of explicit last-exported-repo-version hrefs (replaces last_export).
     * @type {Array<string>}
     * @memberof PulpExport
     */
    start_versions?: Array<string>;
}
/**
 * Serializer for PulpExports.
 * @export
 * @interface PulpExportResponse
 */
export interface PulpExportResponse {
    /**
     * 
     * @type {string}
     * @memberof PulpExportResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PulpExportResponse
     */
    pulp_created?: string;
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof PulpExportResponse
     */
    task?: string | null;
    /**
     * Resources that were exported.
     * @type {Array<any>}
     * @memberof PulpExportResponse
     */
    exported_resources?: Array<any>;
    /**
     * Any additional parameters that were used to create the export.
     * @type {object}
     * @memberof PulpExportResponse
     */
    params?: object;
    /**
     * Dictionary of filename: sha256hash entries for export-output-file(s)
     * @type {object}
     * @memberof PulpExportResponse
     */
    output_file_info?: object;
    /**
     * Filename and sha256-checksum of table-of-contents for this export
     * @type {object}
     * @memberof PulpExportResponse
     */
    toc_info?: object;
}
/**
 * Serializer for pulp exporters.
 * @export
 * @interface PulpExporter
 */
export interface PulpExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PulpExporter
     */
    name: string;
    /**
     * File system directory to store exported tar.gzs.
     * @type {string}
     * @memberof PulpExporter
     */
    path: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PulpExporter
     */
    repositories: Array<string>;
    /**
     * Last attempted export for this PulpExporter
     * @type {string}
     * @memberof PulpExporter
     */
    last_export?: string | null;
}
/**
 * Serializer for pulp exporters.
 * @export
 * @interface PulpExporterResponse
 */
export interface PulpExporterResponse {
    /**
     * 
     * @type {string}
     * @memberof PulpExporterResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PulpExporterResponse
     */
    pulp_created?: string;
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PulpExporterResponse
     */
    name: string;
    /**
     * File system directory to store exported tar.gzs.
     * @type {string}
     * @memberof PulpExporterResponse
     */
    path: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PulpExporterResponse
     */
    repositories: Array<string>;
    /**
     * Last attempted export for this PulpExporter
     * @type {string}
     * @memberof PulpExporterResponse
     */
    last_export?: string | null;
}
/**
 * Serializer for call to import into Pulp.
 * @export
 * @interface PulpImport
 */
export interface PulpImport {
    /**
     * Path to export that will be imported.
     * @type {string}
     * @memberof PulpImport
     */
    path?: string;
    /**
     * Path to a table-of-contents file describing chunks to be validated, reassembled, and imported.
     * @type {string}
     * @memberof PulpImport
     */
    toc?: string;
}
/**
 * Check validity of provided import-options.  Provides the ability to check that an import is \'sane\' without having to actually create an importer.
 * @export
 * @interface PulpImportCheck
 */
export interface PulpImportCheck {
    /**
     * Path to export-tar-gz that will be imported.
     * @type {string}
     * @memberof PulpImportCheck
     */
    path?: string;
    /**
     * Path to a table-of-contents file describing chunks to be validated, reassembled, and imported.
     * @type {string}
     * @memberof PulpImportCheck
     */
    toc?: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {string}
     * @memberof PulpImportCheck
     */
    repo_mapping?: string;
}
/**
 * Return the response to a PulpImport import-check call.
 * @export
 * @interface PulpImportCheckResponse
 */
export interface PulpImportCheckResponse {
    /**
     * Evaluation of proposed \'toc\' file for PulpImport
     * @type {EvaluationResponse}
     * @memberof PulpImportCheckResponse
     */
    toc?: EvaluationResponse;
    /**
     * Evaluation of proposed \'path\' file for PulpImport
     * @type {EvaluationResponse}
     * @memberof PulpImportCheckResponse
     */
    path?: EvaluationResponse;
    /**
     * Evaluation of proposed \'repo_mapping\' file for PulpImport
     * @type {EvaluationResponse}
     * @memberof PulpImportCheckResponse
     */
    repo_mapping?: EvaluationResponse;
}
/**
 * Serializer for PulpImporters.
 * @export
 * @interface PulpImporter
 */
export interface PulpImporter {
    /**
     * Unique name of the Importer.
     * @type {string}
     * @memberof PulpImporter
     */
    name: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {object}
     * @memberof PulpImporter
     */
    repo_mapping?: object;
}
/**
 * Serializer for PulpImporters.
 * @export
 * @interface PulpImporterResponse
 */
export interface PulpImporterResponse {
    /**
     * 
     * @type {string}
     * @memberof PulpImporterResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PulpImporterResponse
     */
    pulp_created?: string;
    /**
     * Unique name of the Importer.
     * @type {string}
     * @memberof PulpImporterResponse
     */
    name: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {object}
     * @memberof PulpImporterResponse
     */
    repo_mapping?: object;
}
/**
 * Serializer for information about the Redis connection
 * @export
 * @interface RedisConnectionResponse
 */
export interface RedisConnectionResponse {
    /**
     * Info about whether the app can connect to Redis
     * @type {boolean}
     * @memberof RedisConnectionResponse
     */
    connected: boolean;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryResponse
 */
export interface RepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RepositoryResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    versions_href?: string;
    /**
     * 
     * @type {object}
     * @memberof RepositoryResponse
     */
    pulp_labels?: object;
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    latest_version_href?: string;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof RepositoryResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof RepositoryResponse
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    remote?: string | null;
}
/**
 * A serializer for the model declaring a signing service.
 * @export
 * @interface SigningServiceResponse
 */
export interface SigningServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof SigningServiceResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    pulp_created?: string;
    /**
     * A unique name used to recognize a script.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    name: string;
    /**
     * The value of a public key used for the repository verification.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    public_key: string;
    /**
     * The fingerprint of the public key.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    pubkey_fingerprint: string;
    /**
     * An absolute path to a script which is going to be used for the signing.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    script: string;
}
/**
 * Serializer for the status information of the app
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * Version information of Pulp components
     * @type {Array<VersionResponse>}
     * @memberof StatusResponse
     */
    versions: Array<VersionResponse>;
    /**
     * List of online workers known to the application. An online worker is actively heartbeating and can respond to new work
     * @type {Array<WorkerResponse>}
     * @memberof StatusResponse
     */
    online_workers: Array<WorkerResponse>;
    /**
     * List of online content apps known to the application. An online content app is actively heartbeating and can serve data to clients
     * @type {Array<ContentAppStatusResponse>}
     * @memberof StatusResponse
     */
    online_content_apps: Array<ContentAppStatusResponse>;
    /**
     * Database connection information
     * @type {DatabaseConnectionResponse}
     * @memberof StatusResponse
     */
    database_connection: DatabaseConnectionResponse;
    /**
     * Redis connection information
     * @type {RedisConnectionResponse}
     * @memberof StatusResponse
     */
    redis_connection: RedisConnectionResponse;
    /**
     * Storage information
     * @type {StorageResponse}
     * @memberof StatusResponse
     */
    storage?: StorageResponse;
}
/**
 * Serializer for information about the storage system
 * @export
 * @interface StorageResponse
 */
export interface StorageResponse {
    /**
     * Total number of bytes
     * @type {number}
     * @memberof StorageResponse
     */
    total: number;
    /**
     * Number of bytes in use
     * @type {number}
     * @memberof StorageResponse
     */
    used: number;
    /**
     * Number of free bytes
     * @type {number}
     * @memberof StorageResponse
     */
    free: number;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface TaskGroupResponse
 */
export interface TaskGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof TaskGroupResponse
     */
    pulp_href?: string;
    /**
     * A description of the task group.
     * @type {string}
     * @memberof TaskGroupResponse
     */
    description: string;
    /**
     * Whether all tasks have been spawned for this task group.
     * @type {boolean}
     * @memberof TaskGroupResponse
     */
    all_tasks_dispatched: boolean;
    /**
     * Number of tasks in the \'waiting\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    waiting?: number;
    /**
     * Number of tasks in the \'skipped\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    skipped?: number;
    /**
     * Number of tasks in the \'running\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    running?: number;
    /**
     * Number of tasks in the \'completed\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    completed?: number;
    /**
     * Number of tasks in the \'canceled\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    canceled?: number;
    /**
     * Number of tasks in the \'failed\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    failed?: number;
    /**
     * 
     * @type {Array<GroupProgressReportResponse>}
     * @memberof TaskGroupResponse
     */
    group_progress_reports?: Array<GroupProgressReportResponse>;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof TaskResponse
     */
    pulp_created?: string;
    /**
     * The current state of the task. The possible values include: \'waiting\', \'skipped\', \'running\', \'completed\', \'failed\' and \'canceled\'.
     * @type {string}
     * @memberof TaskResponse
     */
    state?: string;
    /**
     * The name of task.
     * @type {string}
     * @memberof TaskResponse
     */
    name: string;
    /**
     * The logging correlation id associated with this task
     * @type {string}
     * @memberof TaskResponse
     */
    logging_cid: string;
    /**
     * Timestamp of the when this task started execution.
     * @type {string}
     * @memberof TaskResponse
     */
    started_at?: string;
    /**
     * Timestamp of the when this task stopped execution.
     * @type {string}
     * @memberof TaskResponse
     */
    finished_at?: string;
    /**
     * A JSON Object of a fatal error encountered during the execution of this task.
     * @type {object}
     * @memberof TaskResponse
     */
    error?: object;
    /**
     * The worker associated with this task. This field is empty if a worker is not yet assigned.
     * @type {string}
     * @memberof TaskResponse
     */
    worker?: string;
    /**
     * The parent task that spawned this task.
     * @type {string}
     * @memberof TaskResponse
     */
    parent_task?: string;
    /**
     * Any tasks spawned by this task.
     * @type {Array<string>}
     * @memberof TaskResponse
     */
    child_tasks?: Array<string>;
    /**
     * The task group that this task is a member of.
     * @type {string}
     * @memberof TaskResponse
     */
    task_group?: string;
    /**
     * 
     * @type {Array<ProgressReportResponse>}
     * @memberof TaskResponse
     */
    progress_reports?: Array<ProgressReportResponse>;
    /**
     * Resources created by this task.
     * @type {Array<string>}
     * @memberof TaskResponse
     */
    created_resources?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof TaskResponse
     */
    reserved_resources_record?: Array<object>;
}
/**
 * Serializer for chunked uploads.
 * @export
 * @interface Upload
 */
export interface Upload {
    /**
     * The size of the upload in bytes.
     * @type {number}
     * @memberof Upload
     */
    size: number;
}
/**
 * A mixin for validating unknown serializers\' fields.
 * @export
 * @interface UploadChunkResponse
 */
export interface UploadChunkResponse {
    /**
     * 
     * @type {number}
     * @memberof UploadChunkResponse
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadChunkResponse
     */
    size?: number;
}
/**
 * A mixin for validating unknown serializers\' fields.
 * @export
 * @interface UploadCommit
 */
export interface UploadCommit {
    /**
     * The expected sha256 checksum for the file.
     * @type {string}
     * @memberof UploadCommit
     */
    sha256: string;
}
/**
 * Serializer for chunked uploads.
 * @export
 * @interface UploadDetailResponse
 */
export interface UploadDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadDetailResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof UploadDetailResponse
     */
    pulp_created?: string;
    /**
     * The size of the upload in bytes.
     * @type {number}
     * @memberof UploadDetailResponse
     */
    size: number;
    /**
     * Timestamp when upload is committed.
     * @type {string}
     * @memberof UploadDetailResponse
     */
    completed?: string;
    /**
     * 
     * @type {Array<UploadChunkResponse>}
     * @memberof UploadDetailResponse
     */
    chunks?: Array<UploadChunkResponse>;
}
/**
 * Serializer for chunked uploads.
 * @export
 * @interface UploadResponse
 */
export interface UploadResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof UploadResponse
     */
    pulp_created?: string;
    /**
     * The size of the upload in bytes.
     * @type {number}
     * @memberof UploadResponse
     */
    size: number;
    /**
     * Timestamp when upload is committed.
     * @type {string}
     * @memberof UploadResponse
     */
    completed?: string;
}
/**
 * Serializer for Groups that belong to an User.
 * @export
 * @interface UserGroupResponse
 */
export interface UserGroupResponse {
    /**
     * Name.
     * @type {string}
     * @memberof UserGroupResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroupResponse
     */
    pulp_href?: string;
}
/**
 * Serializer for User.
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    pulp_href?: string;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof UserResponse
     */
    username: string;
    /**
     * First name
     * @type {string}
     * @memberof UserResponse
     */
    first_name: string;
    /**
     * Last name
     * @type {string}
     * @memberof UserResponse
     */
    last_name: string;
    /**
     * Email address
     * @type {string}
     * @memberof UserResponse
     */
    email: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof UserResponse
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active.
     * @type {boolean}
     * @memberof UserResponse
     */
    is_active?: boolean;
    /**
     * Date joined
     * @type {string}
     * @memberof UserResponse
     */
    date_joined?: string;
    /**
     * 
     * @type {Array<UserGroupResponse>}
     * @memberof UserResponse
     */
    groups?: Array<UserGroupResponse>;
}
/**
 * Serializer for the version information of Pulp components
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
    /**
     * Name of a versioned component of Pulp
     * @type {string}
     * @memberof VersionResponse
     */
    component: string;
    /**
     * Version of the component (e.g. 3.0.0)
     * @type {string}
     * @memberof VersionResponse
     */
    version: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface WorkerResponse
 */
export interface WorkerResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkerResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof WorkerResponse
     */
    pulp_created?: string;
    /**
     * The name of the worker.
     * @type {string}
     * @memberof WorkerResponse
     */
    name?: string;
    /**
     * Timestamp of the last time the worker talked to the service.
     * @type {string}
     * @memberof WorkerResponse
     */
    last_heartbeat?: string;
}

/**
 * AccessPoliciesApi - axios parameter creator
 * @export
 */
export const AccessPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List access policys
         * @param {string} [customized] customized
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [viewsetName] viewset_name
         * @param {string} [viewsetNameContains] viewset_name__contains
         * @param {string} [viewsetNameIcontains] viewset_name__icontains
         * @param {string} [viewsetNameIn] viewset_name__in
         * @param {string} [viewsetNameStartswith] viewset_name__startswith
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (customized?: string, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: string, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/access_policies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (customized !== undefined) {
                localVarQueryParameter['customized'] = customized;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (viewsetName !== undefined) {
                localVarQueryParameter['viewset_name'] = viewsetName;
            }

            if (viewsetNameContains !== undefined) {
                localVarQueryParameter['viewset_name__contains'] = viewsetNameContains;
            }

            if (viewsetNameIcontains !== undefined) {
                localVarQueryParameter['viewset_name__icontains'] = viewsetNameIcontains;
            }

            if (viewsetNameIn !== undefined) {
                localVarQueryParameter['viewset_name__in'] = viewsetNameIn;
            }

            if (viewsetNameStartswith !== undefined) {
                localVarQueryParameter['viewset_name__startswith'] = viewsetNameStartswith;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {PatchedAccessPolicy} patchedAccessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessPolicyHref' is not null or undefined
            if (accessPolicyHref === null || accessPolicyHref === undefined) {
                throw new RequiredError('accessPolicyHref','Required parameter accessPolicyHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedAccessPolicy' is not null or undefined
            if (patchedAccessPolicy === null || patchedAccessPolicy === undefined) {
                throw new RequiredError('patchedAccessPolicy','Required parameter patchedAccessPolicy was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{access_policy_href}`
                .replace(`{${"access_policy_href"}}`, encodeURIComponent(String(accessPolicyHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedAccessPolicy !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedAccessPolicy !== undefined ? patchedAccessPolicy : {})
                : (patchedAccessPolicy || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an access policy
         * @param {string} accessPolicyHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (accessPolicyHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessPolicyHref' is not null or undefined
            if (accessPolicyHref === null || accessPolicyHref === undefined) {
                throw new RequiredError('accessPolicyHref','Required parameter accessPolicyHref was null or undefined when calling read.');
            }
            const localVarPath = `{access_policy_href}`
                .replace(`{${"access_policy_href"}}`, encodeURIComponent(String(accessPolicyHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {AccessPolicy} accessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (accessPolicyHref: string, accessPolicy: AccessPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessPolicyHref' is not null or undefined
            if (accessPolicyHref === null || accessPolicyHref === undefined) {
                throw new RequiredError('accessPolicyHref','Required parameter accessPolicyHref was null or undefined when calling update.');
            }
            // verify required parameter 'accessPolicy' is not null or undefined
            if (accessPolicy === null || accessPolicy === undefined) {
                throw new RequiredError('accessPolicy','Required parameter accessPolicy was null or undefined when calling update.');
            }
            const localVarPath = `{access_policy_href}`
                .replace(`{${"access_policy_href"}}`, encodeURIComponent(String(accessPolicyHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accessPolicy !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accessPolicy !== undefined ? accessPolicy : {})
                : (accessPolicy || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessPoliciesApi - functional programming interface
 * @export
 */
export const AccessPoliciesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List access policys
         * @param {string} [customized] customized
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [viewsetName] viewset_name
         * @param {string} [viewsetNameContains] viewset_name__contains
         * @param {string} [viewsetNameIcontains] viewset_name__icontains
         * @param {string} [viewsetNameIn] viewset_name__in
         * @param {string} [viewsetNameStartswith] viewset_name__startswith
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(customized?: string, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: string, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccessPolicyResponseList>> {
            const localVarAxiosArgs = await AccessPoliciesApiAxiosParamCreator(configuration).list(customized, limit, offset, ordering, viewsetName, viewsetNameContains, viewsetNameIcontains, viewsetNameIn, viewsetNameStartswith, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {PatchedAccessPolicy} patchedAccessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPolicyResponse>> {
            const localVarAxiosArgs = await AccessPoliciesApiAxiosParamCreator(configuration).partialUpdate(accessPolicyHref, patchedAccessPolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an access policy
         * @param {string} accessPolicyHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(accessPolicyHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPolicyResponse>> {
            const localVarAxiosArgs = await AccessPoliciesApiAxiosParamCreator(configuration).read(accessPolicyHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {AccessPolicy} accessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(accessPolicyHref: string, accessPolicy: AccessPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPolicyResponse>> {
            const localVarAxiosArgs = await AccessPoliciesApiAxiosParamCreator(configuration).update(accessPolicyHref, accessPolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessPoliciesApi - factory interface
 * @export
 */
export const AccessPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List access policys
         * @param {string} [customized] customized
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [viewsetName] viewset_name
         * @param {string} [viewsetNameContains] viewset_name__contains
         * @param {string} [viewsetNameIcontains] viewset_name__icontains
         * @param {string} [viewsetNameIn] viewset_name__in
         * @param {string} [viewsetNameStartswith] viewset_name__startswith
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customized?: string, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: string, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedAccessPolicyResponseList> {
            return AccessPoliciesApiFp(configuration).list(customized, limit, offset, ordering, viewsetName, viewsetNameContains, viewsetNameIcontains, viewsetNameIn, viewsetNameStartswith, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {PatchedAccessPolicy} patchedAccessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options?: any): AxiosPromise<AccessPolicyResponse> {
            return AccessPoliciesApiFp(configuration).partialUpdate(accessPolicyHref, patchedAccessPolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an access policy
         * @param {string} accessPolicyHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(accessPolicyHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<AccessPolicyResponse> {
            return AccessPoliciesApiFp(configuration).read(accessPolicyHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {AccessPolicy} accessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(accessPolicyHref: string, accessPolicy: AccessPolicy, options?: any): AxiosPromise<AccessPolicyResponse> {
            return AccessPoliciesApiFp(configuration).update(accessPolicyHref, accessPolicy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessPoliciesApi - object-oriented interface
 * @export
 * @class AccessPoliciesApi
 * @extends {BaseAPI}
 */
export class AccessPoliciesApi extends BaseAPI {
    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary List access policys
     * @param {string} [customized] customized
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [viewsetName] viewset_name
     * @param {string} [viewsetNameContains] viewset_name__contains
     * @param {string} [viewsetNameIcontains] viewset_name__icontains
     * @param {string} [viewsetNameIn] viewset_name__in
     * @param {string} [viewsetNameStartswith] viewset_name__startswith
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public list(customized?: string, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: string, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options?: any) {
        return AccessPoliciesApiFp(this.configuration).list(customized, limit, offset, ordering, viewsetName, viewsetNameContains, viewsetNameIcontains, viewsetNameIn, viewsetNameStartswith, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update an access policy
     * @param {string} accessPolicyHref 
     * @param {PatchedAccessPolicy} patchedAccessPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public partialUpdate(accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options?: any) {
        return AccessPoliciesApiFp(this.configuration).partialUpdate(accessPolicyHref, patchedAccessPolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Inspect an access policy
     * @param {string} accessPolicyHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public read(accessPolicyHref: string, fields?: string, excludeFields?: string, options?: any) {
        return AccessPoliciesApiFp(this.configuration).read(accessPolicyHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update an access policy
     * @param {string} accessPolicyHref 
     * @param {AccessPolicy} accessPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public update(accessPolicyHref: string, accessPolicy: AccessPolicy, options?: any) {
        return AccessPoliciesApiFp(this.configuration).update(accessPolicyHref, accessPolicy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove Artifact only if it is not associated with any Content.
         * @summary Delete an artifact
         * @param {string} artifactHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (artifactHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactHref' is not null or undefined
            if (artifactHref === null || artifactHref === undefined) {
                throw new RequiredError('artifactHref','Required parameter artifactHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{artifact_href}`
                .replace(`{${"artifact_href"}}`, encodeURIComponent(String(artifactHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Create an artifact
         * @param {any} file The stored file.
         * @param {number} [size] The size of the file in bytes.
         * @param {string} [md5] The MD5 checksum of the file if available.
         * @param {string} [sha1] The SHA-1 checksum of the file if available.
         * @param {string} [sha224] The SHA-224 checksum of the file if available.
         * @param {string} [sha256] The SHA-256 checksum of the file if available.
         * @param {string} [sha384] The SHA-384 checksum of the file if available.
         * @param {string} [sha512] The SHA-512 checksum of the file if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (size !== undefined) { 
                localVarFormParams.append('size', size as any);
            }
    
            if (md5 !== undefined) { 
                localVarFormParams.append('md5', md5 as any);
            }
    
            if (sha1 !== undefined) { 
                localVarFormParams.append('sha1', sha1 as any);
            }
    
            if (sha224 !== undefined) { 
                localVarFormParams.append('sha224', sha224 as any);
            }
    
            if (sha256 !== undefined) { 
                localVarFormParams.append('sha256', sha256 as any);
            }
    
            if (sha384 !== undefined) { 
                localVarFormParams.append('sha384', sha384 as any);
            }
    
            if (sha512 !== undefined) { 
                localVarFormParams.append('sha512', sha512 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List artifacts
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [md5] md5
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [sha1] sha1
         * @param {string} [sha224] sha224
         * @param {string} [sha256] sha256
         * @param {string} [sha384] sha384
         * @param {string} [sha512] sha512
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (md5 !== undefined) {
                localVarQueryParameter['md5'] = md5;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (sha1 !== undefined) {
                localVarQueryParameter['sha1'] = sha1;
            }

            if (sha224 !== undefined) {
                localVarQueryParameter['sha224'] = sha224;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (sha384 !== undefined) {
                localVarQueryParameter['sha384'] = sha384;
            }

            if (sha512 !== undefined) {
                localVarQueryParameter['sha512'] = sha512;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect an artifact
         * @param {string} artifactHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (artifactHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactHref' is not null or undefined
            if (artifactHref === null || artifactHref === undefined) {
                throw new RequiredError('artifactHref','Required parameter artifactHref was null or undefined when calling read.');
            }
            const localVarPath = `{artifact_href}`
                .replace(`{${"artifact_href"}}`, encodeURIComponent(String(artifactHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove Artifact only if it is not associated with any Content.
         * @summary Delete an artifact
         * @param {string} artifactHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(artifactHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ArtifactsApiAxiosParamCreator(configuration)._delete(artifactHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Create an artifact
         * @param {any} file The stored file.
         * @param {number} [size] The size of the file in bytes.
         * @param {string} [md5] The MD5 checksum of the file if available.
         * @param {string} [sha1] The SHA-1 checksum of the file if available.
         * @param {string} [sha224] The SHA-224 checksum of the file if available.
         * @param {string} [sha256] The SHA-256 checksum of the file if available.
         * @param {string} [sha384] The SHA-384 checksum of the file if available.
         * @param {string} [sha512] The SHA-512 checksum of the file if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactResponse>> {
            const localVarAxiosArgs = await ArtifactsApiAxiosParamCreator(configuration).create(file, size, md5, sha1, sha224, sha256, sha384, sha512, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List artifacts
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [md5] md5
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [sha1] sha1
         * @param {string} [sha224] sha224
         * @param {string} [sha256] sha256
         * @param {string} [sha384] sha384
         * @param {string} [sha512] sha512
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedArtifactResponseList>> {
            const localVarAxiosArgs = await ArtifactsApiAxiosParamCreator(configuration).list(limit, md5, offset, ordering, repositoryVersion, sha1, sha224, sha256, sha384, sha512, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect an artifact
         * @param {string} artifactHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(artifactHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactResponse>> {
            const localVarAxiosArgs = await ArtifactsApiAxiosParamCreator(configuration).read(artifactHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove Artifact only if it is not associated with any Content.
         * @summary Delete an artifact
         * @param {string} artifactHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(artifactHref: string, options?: any): AxiosPromise<void> {
            return ArtifactsApiFp(configuration)._delete(artifactHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Create an artifact
         * @param {any} file The stored file.
         * @param {number} [size] The size of the file in bytes.
         * @param {string} [md5] The MD5 checksum of the file if available.
         * @param {string} [sha1] The SHA-1 checksum of the file if available.
         * @param {string} [sha224] The SHA-224 checksum of the file if available.
         * @param {string} [sha256] The SHA-256 checksum of the file if available.
         * @param {string} [sha384] The SHA-384 checksum of the file if available.
         * @param {string} [sha512] The SHA-512 checksum of the file if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options?: any): AxiosPromise<ArtifactResponse> {
            return ArtifactsApiFp(configuration).create(file, size, md5, sha1, sha224, sha256, sha384, sha512, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List artifacts
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [md5] md5
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [sha1] sha1
         * @param {string} [sha224] sha224
         * @param {string} [sha256] sha256
         * @param {string} [sha384] sha384
         * @param {string} [sha512] sha512
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedArtifactResponseList> {
            return ArtifactsApiFp(configuration).list(limit, md5, offset, ordering, repositoryVersion, sha1, sha224, sha256, sha384, sha512, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect an artifact
         * @param {string} artifactHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(artifactHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<ArtifactResponse> {
            return ArtifactsApiFp(configuration).read(artifactHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * Remove Artifact only if it is not associated with any Content.
     * @summary Delete an artifact
     * @param {string} artifactHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public _delete(artifactHref: string, options?: any) {
        return ArtifactsApiFp(this.configuration)._delete(artifactHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Create an artifact
     * @param {any} file The stored file.
     * @param {number} [size] The size of the file in bytes.
     * @param {string} [md5] The MD5 checksum of the file if available.
     * @param {string} [sha1] The SHA-1 checksum of the file if available.
     * @param {string} [sha224] The SHA-224 checksum of the file if available.
     * @param {string} [sha256] The SHA-256 checksum of the file if available.
     * @param {string} [sha384] The SHA-384 checksum of the file if available.
     * @param {string} [sha512] The SHA-512 checksum of the file if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public create(file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).create(file, size, md5, sha1, sha224, sha256, sha384, sha512, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List artifacts
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [md5] md5
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] repository_version
     * @param {string} [sha1] sha1
     * @param {string} [sha224] sha224
     * @param {string} [sha256] sha256
     * @param {string} [sha384] sha384
     * @param {string} [sha512] sha512
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public list(limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).list(limit, md5, offset, ordering, repositoryVersion, sha1, sha224, sha256, sha384, sha512, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect an artifact
     * @param {string} artifactHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public read(artifactHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).read(artifactHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all content.
         * @summary List content
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [repositoryVersionAdded] repository_version_added
         * @param {string} [repositoryVersionRemoved] repository_version_removed
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all content.
         * @summary List content
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [repositoryVersionAdded] repository_version_added
         * @param {string} [repositoryVersionRemoved] repository_version_removed
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMultipleArtifactContentResponseList>> {
            const localVarAxiosArgs = await ContentApiAxiosParamCreator(configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Endpoint to list all content.
         * @summary List content
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [repositoryVersionAdded] repository_version_added
         * @param {string} [repositoryVersionRemoved] repository_version_removed
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedMultipleArtifactContentResponseList> {
            return ContentApiFp(configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Endpoint to list all content.
     * @summary List content
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] repository_version
     * @param {string} [repositoryVersionAdded] repository_version_added
     * @param {string} [repositoryVersionRemoved] repository_version_removed
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContentGuardsApi - axios parameter creator
 * @export
 */
export const ContentGuardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all content_guards.
         * @summary List content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content_guards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGuardsApi - functional programming interface
 * @export
 */
export const ContentGuardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all content_guards.
         * @summary List content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContentGuardResponseList>> {
            const localVarAxiosArgs = await ContentGuardsApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContentGuardsApi - factory interface
 * @export
 */
export const ContentGuardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Endpoint to list all content_guards.
         * @summary List content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedContentGuardResponseList> {
            return ContentGuardsApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGuardsApi - object-oriented interface
 * @export
 * @class ContentGuardsApi
 * @extends {BaseAPI}
 */
export class ContentGuardsApi extends BaseAPI {
    /**
     * Endpoint to list all content_guards.
     * @summary List content guards
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGuardsApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentGuardsApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportersCoreExportsApi - axios parameter creator
 * @export
 */
export const ExportersCoreExportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Delete a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpPulpExportHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpExportHref' is not null or undefined
            if (pulpPulpExportHref === null || pulpPulpExportHref === undefined) {
                throw new RequiredError('pulpPulpExportHref','Required parameter pulpPulpExportHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{pulp_pulp_export_href}`
                .replace(`{${"pulp_pulp_export_href"}}`, encodeURIComponent(String(pulpPulpExportHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to export a set of repositories
         * @summary Create a pulp export
         * @param {string} pulpExporterHref 
         * @param {PulpExport} pulpExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpExporterHref: string, pulpExport: PulpExport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            if (pulpExporterHref === null || pulpExporterHref === undefined) {
                throw new RequiredError('pulpExporterHref','Required parameter pulpExporterHref was null or undefined when calling create.');
            }
            // verify required parameter 'pulpExport' is not null or undefined
            if (pulpExport === null || pulpExport === undefined) {
                throw new RequiredError('pulpExport','Required parameter pulpExport was null or undefined when calling create.');
            }
            const localVarPath = `{pulp_exporter_href}exports/`
                .replace(`{${"pulp_exporter_href"}}`, encodeURIComponent(String(pulpExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpExport !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpExport !== undefined ? pulpExport : {})
                : (pulpExport || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary List pulp exports
         * @param {string} pulpExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            if (pulpExporterHref === null || pulpExporterHref === undefined) {
                throw new RequiredError('pulpExporterHref','Required parameter pulpExporterHref was null or undefined when calling list.');
            }
            const localVarPath = `{pulp_exporter_href}exports/`
                .replace(`{${"pulp_exporter_href"}}`, encodeURIComponent(String(pulpExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Inspect a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpPulpExportHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpExportHref' is not null or undefined
            if (pulpPulpExportHref === null || pulpPulpExportHref === undefined) {
                throw new RequiredError('pulpPulpExportHref','Required parameter pulpPulpExportHref was null or undefined when calling read.');
            }
            const localVarPath = `{pulp_pulp_export_href}`
                .replace(`{${"pulp_pulp_export_href"}}`, encodeURIComponent(String(pulpPulpExportHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersCoreExportsApi - functional programming interface
 * @export
 */
export const ExportersCoreExportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Delete a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpPulpExportHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExportersCoreExportsApiAxiosParamCreator(configuration)._delete(pulpPulpExportHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to export a set of repositories
         * @summary Create a pulp export
         * @param {string} pulpExporterHref 
         * @param {PulpExport} pulpExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpExporterHref: string, pulpExport: PulpExport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await ExportersCoreExportsApiAxiosParamCreator(configuration).create(pulpExporterHref, pulpExport, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary List pulp exports
         * @param {string} pulpExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPulpExportResponseList>> {
            const localVarAxiosArgs = await ExportersCoreExportsApiAxiosParamCreator(configuration).list(pulpExporterHref, limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Inspect a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpPulpExportHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExportResponse>> {
            const localVarAxiosArgs = await ExportersCoreExportsApiAxiosParamCreator(configuration).read(pulpPulpExportHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportersCoreExportsApi - factory interface
 * @export
 */
export const ExportersCoreExportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Delete a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpPulpExportHref: string, options?: any): AxiosPromise<void> {
            return ExportersCoreExportsApiFp(configuration)._delete(pulpPulpExportHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to export a set of repositories
         * @summary Create a pulp export
         * @param {string} pulpExporterHref 
         * @param {PulpExport} pulpExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpExporterHref: string, pulpExport: PulpExport, options?: any): AxiosPromise<AsyncOperationResponse> {
            return ExportersCoreExportsApiFp(configuration).create(pulpExporterHref, pulpExport, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary List pulp exports
         * @param {string} pulpExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPulpExportResponseList> {
            return ExportersCoreExportsApiFp(configuration).list(pulpExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Inspect a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpPulpExportHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PulpExportResponse> {
            return ExportersCoreExportsApiFp(configuration).read(pulpPulpExportHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersCoreExportsApi - object-oriented interface
 * @export
 * @class ExportersCoreExportsApi
 * @extends {BaseAPI}
 */
export class ExportersCoreExportsApi extends BaseAPI {
    /**
     * ViewSet for viewing exports from a PulpExporter.
     * @summary Delete a pulp export
     * @param {string} pulpPulpExportHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersCoreExportsApi
     */
    public _delete(pulpPulpExportHref: string, options?: any) {
        return ExportersCoreExportsApiFp(this.configuration)._delete(pulpPulpExportHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to export a set of repositories
     * @summary Create a pulp export
     * @param {string} pulpExporterHref 
     * @param {PulpExport} pulpExport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersCoreExportsApi
     */
    public create(pulpExporterHref: string, pulpExport: PulpExport, options?: any) {
        return ExportersCoreExportsApiFp(this.configuration).create(pulpExporterHref, pulpExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing exports from a PulpExporter.
     * @summary List pulp exports
     * @param {string} pulpExporterHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersCoreExportsApi
     */
    public list(pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersCoreExportsApiFp(this.configuration).list(pulpExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing exports from a PulpExporter.
     * @summary Inspect a pulp export
     * @param {string} pulpPulpExportHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersCoreExportsApi
     */
    public read(pulpPulpExportHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersCoreExportsApiFp(this.configuration).read(pulpPulpExportHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportersPulpApi - axios parameter creator
 * @export
 */
export const ExportersPulpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Delete a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpExporterHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            if (pulpExporterHref === null || pulpExporterHref === undefined) {
                throw new RequiredError('pulpExporterHref','Required parameter pulpExporterHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, encodeURIComponent(String(pulpExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Create a pulp exporter
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpExporter: PulpExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporter' is not null or undefined
            if (pulpExporter === null || pulpExporter === undefined) {
                throw new RequiredError('pulpExporter','Required parameter pulpExporter was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/exporters/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpExporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpExporter !== undefined ? pulpExporter : {})
                : (pulpExporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary List pulp exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/exporters/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PatchedPulpExporter} patchedPulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            if (pulpExporterHref === null || pulpExporterHref === undefined) {
                throw new RequiredError('pulpExporterHref','Required parameter pulpExporterHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedPulpExporter' is not null or undefined
            if (patchedPulpExporter === null || patchedPulpExporter === undefined) {
                throw new RequiredError('patchedPulpExporter','Required parameter patchedPulpExporter was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, encodeURIComponent(String(pulpExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedPulpExporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedPulpExporter !== undefined ? patchedPulpExporter : {})
                : (patchedPulpExporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Inspect a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpExporterHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            if (pulpExporterHref === null || pulpExporterHref === undefined) {
                throw new RequiredError('pulpExporterHref','Required parameter pulpExporterHref was null or undefined when calling read.');
            }
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, encodeURIComponent(String(pulpExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (pulpExporterHref: string, pulpExporter: PulpExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            if (pulpExporterHref === null || pulpExporterHref === undefined) {
                throw new RequiredError('pulpExporterHref','Required parameter pulpExporterHref was null or undefined when calling update.');
            }
            // verify required parameter 'pulpExporter' is not null or undefined
            if (pulpExporter === null || pulpExporter === undefined) {
                throw new RequiredError('pulpExporter','Required parameter pulpExporter was null or undefined when calling update.');
            }
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, encodeURIComponent(String(pulpExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpExporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpExporter !== undefined ? pulpExporter : {})
                : (pulpExporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersPulpApi - functional programming interface
 * @export
 */
export const ExportersPulpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Delete a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpExporterHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExportersPulpApiAxiosParamCreator(configuration)._delete(pulpExporterHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Create a pulp exporter
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpExporter: PulpExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExporterResponse>> {
            const localVarAxiosArgs = await ExportersPulpApiAxiosParamCreator(configuration).create(pulpExporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary List pulp exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPulpExporterResponseList>> {
            const localVarAxiosArgs = await ExportersPulpApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PatchedPulpExporter} patchedPulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExporterResponse>> {
            const localVarAxiosArgs = await ExportersPulpApiAxiosParamCreator(configuration).partialUpdate(pulpExporterHref, patchedPulpExporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Inspect a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpExporterHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExporterResponse>> {
            const localVarAxiosArgs = await ExportersPulpApiAxiosParamCreator(configuration).read(pulpExporterHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(pulpExporterHref: string, pulpExporter: PulpExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExporterResponse>> {
            const localVarAxiosArgs = await ExportersPulpApiAxiosParamCreator(configuration).update(pulpExporterHref, pulpExporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportersPulpApi - factory interface
 * @export
 */
export const ExportersPulpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Delete a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpExporterHref: string, options?: any): AxiosPromise<void> {
            return ExportersPulpApiFp(configuration)._delete(pulpExporterHref, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Create a pulp exporter
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpExporter: PulpExporter, options?: any): AxiosPromise<PulpExporterResponse> {
            return ExportersPulpApiFp(configuration).create(pulpExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary List pulp exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPulpExporterResponseList> {
            return ExportersPulpApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PatchedPulpExporter} patchedPulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options?: any): AxiosPromise<PulpExporterResponse> {
            return ExportersPulpApiFp(configuration).partialUpdate(pulpExporterHref, patchedPulpExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Inspect a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpExporterHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PulpExporterResponse> {
            return ExportersPulpApiFp(configuration).read(pulpExporterHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(pulpExporterHref: string, pulpExporter: PulpExporter, options?: any): AxiosPromise<PulpExporterResponse> {
            return ExportersPulpApiFp(configuration).update(pulpExporterHref, pulpExporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersPulpApi - object-oriented interface
 * @export
 * @class ExportersPulpApi
 * @extends {BaseAPI}
 */
export class ExportersPulpApi extends BaseAPI {
    /**
     * ViewSet for viewing PulpExporters.
     * @summary Delete a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public _delete(pulpExporterHref: string, options?: any) {
        return ExportersPulpApiFp(this.configuration)._delete(pulpExporterHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary Create a pulp exporter
     * @param {PulpExporter} pulpExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public create(pulpExporter: PulpExporter, options?: any) {
        return ExportersPulpApiFp(this.configuration).create(pulpExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary List pulp exporters
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersPulpApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary Update a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {PatchedPulpExporter} patchedPulpExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public partialUpdate(pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options?: any) {
        return ExportersPulpApiFp(this.configuration).partialUpdate(pulpExporterHref, patchedPulpExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary Inspect a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public read(pulpExporterHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersPulpApiFp(this.configuration).read(pulpExporterHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary Update a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {PulpExporter} pulpExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public update(pulpExporterHref: string, pulpExporter: PulpExporter, options?: any) {
        return ExportersPulpApiFp(this.configuration).update(pulpExporterHref, pulpExporter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Delete a group
         * @param {string} authGroupHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Create a group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof group !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(group !== undefined ? group : {})
                : (group || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List groups
         * @param {string} [id] id
         * @param {string} [idIn] id__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIexact] name__iexact
         * @param {string} [nameIn] name__in
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (id?: string, idIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['id__in'] = idIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIexact !== undefined) {
                localVarQueryParameter['name__iexact'] = nameIexact;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {PatchedGroup} patchedGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (authGroupHref: string, patchedGroup: PatchedGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedGroup' is not null or undefined
            if (patchedGroup === null || patchedGroup === undefined) {
                throw new RequiredError('patchedGroup','Required parameter patchedGroup was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedGroup !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedGroup !== undefined ? patchedGroup : {})
                : (patchedGroup || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect a group
         * @param {string} authGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authGroupHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling read.');
            }
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (authGroupHref: string, group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling update.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling update.');
            }
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof group !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(group !== undefined ? group : {})
                : (group || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Delete a group
         * @param {string} authGroupHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration)._delete(authGroupHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Create a group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).create(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List groups
         * @param {string} [id] id
         * @param {string} [idIn] id__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIexact] name__iexact
         * @param {string} [nameIn] name__in
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(id?: string, idIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupResponseList>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).list(id, idIn, limit, name, nameContains, nameIcontains, nameIexact, nameIn, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {PatchedGroup} patchedGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(authGroupHref: string, patchedGroup: PatchedGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).partialUpdate(authGroupHref, patchedGroup, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect a group
         * @param {string} authGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authGroupHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).read(authGroupHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(authGroupHref: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).update(authGroupHref, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Delete a group
         * @param {string} authGroupHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupHref: string, options?: any): AxiosPromise<void> {
            return GroupsApiFp(configuration)._delete(authGroupHref, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Create a group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(group: Group, options?: any): AxiosPromise<GroupResponse> {
            return GroupsApiFp(configuration).create(group, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List groups
         * @param {string} [id] id
         * @param {string} [idIn] id__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIexact] name__iexact
         * @param {string} [nameIn] name__in
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(id?: string, idIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedGroupResponseList> {
            return GroupsApiFp(configuration).list(id, idIn, limit, name, nameContains, nameIcontains, nameIexact, nameIn, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {PatchedGroup} patchedGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(authGroupHref: string, patchedGroup: PatchedGroup, options?: any): AxiosPromise<GroupResponse> {
            return GroupsApiFp(configuration).partialUpdate(authGroupHref, patchedGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect a group
         * @param {string} authGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authGroupHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<GroupResponse> {
            return GroupsApiFp(configuration).read(authGroupHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(authGroupHref: string, group: Group, options?: any): AxiosPromise<GroupResponse> {
            return GroupsApiFp(configuration).update(authGroupHref, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Delete a group
     * @param {string} authGroupHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public _delete(authGroupHref: string, options?: any) {
        return GroupsApiFp(this.configuration)._delete(authGroupHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Create a group
     * @param {Group} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public create(group: Group, options?: any) {
        return GroupsApiFp(this.configuration).create(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary List groups
     * @param {string} [id] id
     * @param {string} [idIn] id__in
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIexact] name__iexact
     * @param {string} [nameIn] name__in
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public list(id?: string, idIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsApiFp(this.configuration).list(id, idIn, limit, name, nameContains, nameIcontains, nameIexact, nameIn, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update a group
     * @param {string} authGroupHref 
     * @param {PatchedGroup} patchedGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public partialUpdate(authGroupHref: string, patchedGroup: PatchedGroup, options?: any) {
        return GroupsApiFp(this.configuration).partialUpdate(authGroupHref, patchedGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Inspect a group
     * @param {string} authGroupHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public read(authGroupHref: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsApiFp(this.configuration).read(authGroupHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update a group
     * @param {string} authGroupHref 
     * @param {Group} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public update(authGroupHref: string, group: Group, options?: any) {
        return GroupsApiFp(this.configuration).update(authGroupHref, group, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsModelPermissionsApi - axios parameter creator
 * @export
 */
export const GroupsModelPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a model permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupsModelPermissionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsModelPermissionHref' is not null or undefined
            if (authGroupsModelPermissionHref === null || authGroupsModelPermissionHref === undefined) {
                throw new RequiredError('authGroupsModelPermissionHref','Required parameter authGroupsModelPermissionHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{auth_groups_model_permission_href}`
                .replace(`{${"auth_groups_model_permission_href"}}`, encodeURIComponent(String(authGroupsModelPermissionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a model permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (authGroupHref: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling create.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
            }
            const localVarPath = `{auth_group_href}model_permissions/`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List group permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling list.');
            }
            const localVarPath = `{auth_group_href}model_permissions/`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsModelPermissionHref' is not null or undefined
            if (authGroupsModelPermissionHref === null || authGroupsModelPermissionHref === undefined) {
                throw new RequiredError('authGroupsModelPermissionHref','Required parameter authGroupsModelPermissionHref was null or undefined when calling read.');
            }
            const localVarPath = `{auth_groups_model_permission_href}`
                .replace(`{${"auth_groups_model_permission_href"}}`, encodeURIComponent(String(authGroupsModelPermissionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsModelPermissionsApi - functional programming interface
 * @export
 */
export const GroupsModelPermissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove a model permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupsModelPermissionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsModelPermissionsApiAxiosParamCreator(configuration)._delete(authGroupsModelPermissionHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a model permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(authGroupHref: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await GroupsModelPermissionsApiAxiosParamCreator(configuration).create(authGroupHref, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List group permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPermissionResponseList>> {
            const localVarAxiosArgs = await GroupsModelPermissionsApiAxiosParamCreator(configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await GroupsModelPermissionsApiAxiosParamCreator(configuration).read(authGroupsModelPermissionHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupsModelPermissionsApi - factory interface
 * @export
 */
export const GroupsModelPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove a model permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupsModelPermissionHref: string, options?: any): AxiosPromise<void> {
            return GroupsModelPermissionsApiFp(configuration)._delete(authGroupsModelPermissionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a model permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(authGroupHref: string, body: object, options?: any): AxiosPromise<PermissionResponse> {
            return GroupsModelPermissionsApiFp(configuration).create(authGroupHref, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List group permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPermissionResponseList> {
            return GroupsModelPermissionsApiFp(configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PermissionResponse> {
            return GroupsModelPermissionsApiFp(configuration).read(authGroupsModelPermissionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsModelPermissionsApi - object-oriented interface
 * @export
 * @class GroupsModelPermissionsApi
 * @extends {BaseAPI}
 */
export class GroupsModelPermissionsApi extends BaseAPI {
    /**
     * Remove a model permission from a group.
     * @summary Delete a permission
     * @param {string} authGroupsModelPermissionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public _delete(authGroupsModelPermissionHref: string, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration)._delete(authGroupsModelPermissionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a model permission to a group.
     * @summary Create a permission
     * @param {string} authGroupHref 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public create(authGroupHref: string, body: object, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration).create(authGroupHref, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List group permissions.
     * @summary List permissions
     * @param {string} authGroupHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a model permission from a group.
     * @summary Inspect a permission
     * @param {string} authGroupsModelPermissionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public read(authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration).read(authGroupsModelPermissionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsObjectPermissionsApi - axios parameter creator
 * @export
 */
export const GroupsObjectPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove an object permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupsObjectPermissionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsObjectPermissionHref' is not null or undefined
            if (authGroupsObjectPermissionHref === null || authGroupsObjectPermissionHref === undefined) {
                throw new RequiredError('authGroupsObjectPermissionHref','Required parameter authGroupsObjectPermissionHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{auth_groups_object_permission_href}`
                .replace(`{${"auth_groups_object_permission_href"}}`, encodeURIComponent(String(authGroupsObjectPermissionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an object permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (authGroupHref: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling create.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
            }
            const localVarPath = `{auth_group_href}object_permissions/`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List group object permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling list.');
            }
            const localVarPath = `{auth_group_href}object_permissions/`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsObjectPermissionHref' is not null or undefined
            if (authGroupsObjectPermissionHref === null || authGroupsObjectPermissionHref === undefined) {
                throw new RequiredError('authGroupsObjectPermissionHref','Required parameter authGroupsObjectPermissionHref was null or undefined when calling read.');
            }
            const localVarPath = `{auth_groups_object_permission_href}`
                .replace(`{${"auth_groups_object_permission_href"}}`, encodeURIComponent(String(authGroupsObjectPermissionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsObjectPermissionsApi - functional programming interface
 * @export
 */
export const GroupsObjectPermissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove an object permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupsObjectPermissionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsObjectPermissionsApiAxiosParamCreator(configuration)._delete(authGroupsObjectPermissionHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add an object permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(authGroupHref: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await GroupsObjectPermissionsApiAxiosParamCreator(configuration).create(authGroupHref, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List group object permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPermissionResponseList>> {
            const localVarAxiosArgs = await GroupsObjectPermissionsApiAxiosParamCreator(configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await GroupsObjectPermissionsApiAxiosParamCreator(configuration).read(authGroupsObjectPermissionHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupsObjectPermissionsApi - factory interface
 * @export
 */
export const GroupsObjectPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove an object permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupsObjectPermissionHref: string, options?: any): AxiosPromise<void> {
            return GroupsObjectPermissionsApiFp(configuration)._delete(authGroupsObjectPermissionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an object permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(authGroupHref: string, body: object, options?: any): AxiosPromise<PermissionResponse> {
            return GroupsObjectPermissionsApiFp(configuration).create(authGroupHref, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List group object permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPermissionResponseList> {
            return GroupsObjectPermissionsApiFp(configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PermissionResponse> {
            return GroupsObjectPermissionsApiFp(configuration).read(authGroupsObjectPermissionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsObjectPermissionsApi - object-oriented interface
 * @export
 * @class GroupsObjectPermissionsApi
 * @extends {BaseAPI}
 */
export class GroupsObjectPermissionsApi extends BaseAPI {
    /**
     * Remove an object permission from a group.
     * @summary Delete a permission
     * @param {string} authGroupsObjectPermissionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public _delete(authGroupsObjectPermissionHref: string, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration)._delete(authGroupsObjectPermissionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an object permission to a group.
     * @summary Create a permission
     * @param {string} authGroupHref 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public create(authGroupHref: string, body: object, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration).create(authGroupHref, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List group object permissions.
     * @summary List permissions
     * @param {string} authGroupHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a model permission from a group.
     * @summary Inspect a permission
     * @param {string} authGroupsObjectPermissionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public read(authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration).read(authGroupsObjectPermissionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsUsersApi - axios parameter creator
 * @export
 */
export const GroupsUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a user from a group.
         * @summary Delete an user
         * @param {string} authGroupsUserHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupsUserHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsUserHref' is not null or undefined
            if (authGroupsUserHref === null || authGroupsUserHref === undefined) {
                throw new RequiredError('authGroupsUserHref','Required parameter authGroupsUserHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{auth_groups_user_href}`
                .replace(`{${"auth_groups_user_href"}}`, encodeURIComponent(String(authGroupsUserHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a user to a group.
         * @summary Create an user
         * @param {string} authGroupHref 
         * @param {GroupUser} groupUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (authGroupHref: string, groupUser: GroupUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling create.');
            }
            // verify required parameter 'groupUser' is not null or undefined
            if (groupUser === null || groupUser === undefined) {
                throw new RequiredError('groupUser','Required parameter groupUser was null or undefined when calling create.');
            }
            const localVarPath = `{auth_group_href}users/`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof groupUser !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(groupUser !== undefined ? groupUser : {})
                : (groupUser || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List group users.
         * @summary List users
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            if (authGroupHref === null || authGroupHref === undefined) {
                throw new RequiredError('authGroupHref','Required parameter authGroupHref was null or undefined when calling list.');
            }
            const localVarPath = `{auth_group_href}users/`
                .replace(`{${"auth_group_href"}}`, encodeURIComponent(String(authGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsUsersApi - functional programming interface
 * @export
 */
export const GroupsUsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove a user from a group.
         * @summary Delete an user
         * @param {string} authGroupsUserHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupsUserHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsUsersApiAxiosParamCreator(configuration)._delete(authGroupsUserHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a user to a group.
         * @summary Create an user
         * @param {string} authGroupHref 
         * @param {GroupUser} groupUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(authGroupHref: string, groupUser: GroupUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUserResponse>> {
            const localVarAxiosArgs = await GroupsUsersApiAxiosParamCreator(configuration).create(authGroupHref, groupUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List group users.
         * @summary List users
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupUserResponseList>> {
            const localVarAxiosArgs = await GroupsUsersApiAxiosParamCreator(configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupsUsersApi - factory interface
 * @export
 */
export const GroupsUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove a user from a group.
         * @summary Delete an user
         * @param {string} authGroupsUserHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupsUserHref: string, options?: any): AxiosPromise<void> {
            return GroupsUsersApiFp(configuration)._delete(authGroupsUserHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a user to a group.
         * @summary Create an user
         * @param {string} authGroupHref 
         * @param {GroupUser} groupUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(authGroupHref: string, groupUser: GroupUser, options?: any): AxiosPromise<GroupUserResponse> {
            return GroupsUsersApiFp(configuration).create(authGroupHref, groupUser, options).then((request) => request(axios, basePath));
        },
        /**
         * List group users.
         * @summary List users
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedGroupUserResponseList> {
            return GroupsUsersApiFp(configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsUsersApi - object-oriented interface
 * @export
 * @class GroupsUsersApi
 * @extends {BaseAPI}
 */
export class GroupsUsersApi extends BaseAPI {
    /**
     * Remove a user from a group.
     * @summary Delete an user
     * @param {string} authGroupsUserHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsUsersApi
     */
    public _delete(authGroupsUserHref: string, options?: any) {
        return GroupsUsersApiFp(this.configuration)._delete(authGroupsUserHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a user to a group.
     * @summary Create an user
     * @param {string} authGroupHref 
     * @param {GroupUser} groupUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsUsersApi
     */
    public create(authGroupHref: string, groupUser: GroupUser, options?: any) {
        return GroupsUsersApiFp(this.configuration).create(authGroupHref, groupUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List group users.
     * @summary List users
     * @param {string} authGroupHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsUsersApi
     */
    public list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsUsersApiFp(this.configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportersCoreImportCheckApi - axios parameter creator
 * @export
 */
export const ImportersCoreImportCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
         * @summary Validate the parameters to be used for a PulpImport call
         * @param {PulpImportCheck} pulpImportCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pulpImportCheckPost: async (pulpImportCheck: PulpImportCheck, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImportCheck' is not null or undefined
            if (pulpImportCheck === null || pulpImportCheck === undefined) {
                throw new RequiredError('pulpImportCheck','Required parameter pulpImportCheck was null or undefined when calling pulpImportCheckPost.');
            }
            const localVarPath = `/pulp/api/v3/importers/core/pulp/import-check/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpImportCheck !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpImportCheck !== undefined ? pulpImportCheck : {})
                : (pulpImportCheck || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportersCoreImportCheckApi - functional programming interface
 * @export
 */
export const ImportersCoreImportCheckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
         * @summary Validate the parameters to be used for a PulpImport call
         * @param {PulpImportCheck} pulpImportCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pulpImportCheckPost(pulpImportCheck: PulpImportCheck, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImportCheckResponse>> {
            const localVarAxiosArgs = await ImportersCoreImportCheckApiAxiosParamCreator(configuration).pulpImportCheckPost(pulpImportCheck, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImportersCoreImportCheckApi - factory interface
 * @export
 */
export const ImportersCoreImportCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
         * @summary Validate the parameters to be used for a PulpImport call
         * @param {PulpImportCheck} pulpImportCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pulpImportCheckPost(pulpImportCheck: PulpImportCheck, options?: any): AxiosPromise<PulpImportCheckResponse> {
            return ImportersCoreImportCheckApiFp(configuration).pulpImportCheckPost(pulpImportCheck, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportersCoreImportCheckApi - object-oriented interface
 * @export
 * @class ImportersCoreImportCheckApi
 * @extends {BaseAPI}
 */
export class ImportersCoreImportCheckApi extends BaseAPI {
    /**
     * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
     * @summary Validate the parameters to be used for a PulpImport call
     * @param {PulpImportCheck} pulpImportCheck 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersCoreImportCheckApi
     */
    public pulpImportCheckPost(pulpImportCheck: PulpImportCheck, options?: any) {
        return ImportersCoreImportCheckApiFp(this.configuration).pulpImportCheckPost(pulpImportCheck, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportersCoreImportsApi - axios parameter creator
 * @export
 */
export const ImportersCoreImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for PulpImports.
         * @summary Delete a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpPulpImportHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpImportHref' is not null or undefined
            if (pulpPulpImportHref === null || pulpPulpImportHref === undefined) {
                throw new RequiredError('pulpPulpImportHref','Required parameter pulpPulpImportHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{pulp_pulp_import_href}`
                .replace(`{${"pulp_pulp_import_href"}}`, encodeURIComponent(String(pulpPulpImportHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to import a Pulp export.
         * @summary Create a pulp import
         * @param {string} pulpImporterHref 
         * @param {PulpImport} pulpImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpImporterHref: string, pulpImport: PulpImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            if (pulpImporterHref === null || pulpImporterHref === undefined) {
                throw new RequiredError('pulpImporterHref','Required parameter pulpImporterHref was null or undefined when calling create.');
            }
            // verify required parameter 'pulpImport' is not null or undefined
            if (pulpImport === null || pulpImport === undefined) {
                throw new RequiredError('pulpImport','Required parameter pulpImport was null or undefined when calling create.');
            }
            const localVarPath = `{pulp_importer_href}imports/`
                .replace(`{${"pulp_importer_href"}}`, encodeURIComponent(String(pulpImporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpImport !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpImport !== undefined ? pulpImport : {})
                : (pulpImport || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImports.
         * @summary List pulp imports
         * @param {string} pulpImporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            if (pulpImporterHref === null || pulpImporterHref === undefined) {
                throw new RequiredError('pulpImporterHref','Required parameter pulpImporterHref was null or undefined when calling list.');
            }
            const localVarPath = `{pulp_importer_href}imports/`
                .replace(`{${"pulp_importer_href"}}`, encodeURIComponent(String(pulpImporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImports.
         * @summary Inspect a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpPulpImportHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpImportHref' is not null or undefined
            if (pulpPulpImportHref === null || pulpPulpImportHref === undefined) {
                throw new RequiredError('pulpPulpImportHref','Required parameter pulpPulpImportHref was null or undefined when calling read.');
            }
            const localVarPath = `{pulp_pulp_import_href}`
                .replace(`{${"pulp_pulp_import_href"}}`, encodeURIComponent(String(pulpPulpImportHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportersCoreImportsApi - functional programming interface
 * @export
 */
export const ImportersCoreImportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for PulpImports.
         * @summary Delete a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpPulpImportHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImportersCoreImportsApiAxiosParamCreator(configuration)._delete(pulpPulpImportHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to import a Pulp export.
         * @summary Create a pulp import
         * @param {string} pulpImporterHref 
         * @param {PulpImport} pulpImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpImporterHref: string, pulpImport: PulpImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await ImportersCoreImportsApiAxiosParamCreator(configuration).create(pulpImporterHref, pulpImport, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImports.
         * @summary List pulp imports
         * @param {string} pulpImporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedImportResponseList>> {
            const localVarAxiosArgs = await ImportersCoreImportsApiAxiosParamCreator(configuration).list(pulpImporterHref, limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImports.
         * @summary Inspect a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpPulpImportHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportResponse>> {
            const localVarAxiosArgs = await ImportersCoreImportsApiAxiosParamCreator(configuration).read(pulpPulpImportHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImportersCoreImportsApi - factory interface
 * @export
 */
export const ImportersCoreImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for PulpImports.
         * @summary Delete a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpPulpImportHref: string, options?: any): AxiosPromise<void> {
            return ImportersCoreImportsApiFp(configuration)._delete(pulpPulpImportHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to import a Pulp export.
         * @summary Create a pulp import
         * @param {string} pulpImporterHref 
         * @param {PulpImport} pulpImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpImporterHref: string, pulpImport: PulpImport, options?: any): AxiosPromise<AsyncOperationResponse> {
            return ImportersCoreImportsApiFp(configuration).create(pulpImporterHref, pulpImport, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImports.
         * @summary List pulp imports
         * @param {string} pulpImporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedImportResponseList> {
            return ImportersCoreImportsApiFp(configuration).list(pulpImporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImports.
         * @summary Inspect a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpPulpImportHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<ImportResponse> {
            return ImportersCoreImportsApiFp(configuration).read(pulpPulpImportHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportersCoreImportsApi - object-oriented interface
 * @export
 * @class ImportersCoreImportsApi
 * @extends {BaseAPI}
 */
export class ImportersCoreImportsApi extends BaseAPI {
    /**
     * ViewSet for PulpImports.
     * @summary Delete a pulp import
     * @param {string} pulpPulpImportHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersCoreImportsApi
     */
    public _delete(pulpPulpImportHref: string, options?: any) {
        return ImportersCoreImportsApiFp(this.configuration)._delete(pulpPulpImportHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to import a Pulp export.
     * @summary Create a pulp import
     * @param {string} pulpImporterHref 
     * @param {PulpImport} pulpImport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersCoreImportsApi
     */
    public create(pulpImporterHref: string, pulpImport: PulpImport, options?: any) {
        return ImportersCoreImportsApiFp(this.configuration).create(pulpImporterHref, pulpImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImports.
     * @summary List pulp imports
     * @param {string} pulpImporterHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersCoreImportsApi
     */
    public list(pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersCoreImportsApiFp(this.configuration).list(pulpImporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImports.
     * @summary Inspect a pulp import
     * @param {string} pulpPulpImportHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersCoreImportsApi
     */
    public read(pulpPulpImportHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersCoreImportsApiFp(this.configuration).read(pulpPulpImportHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportersPulpApi - axios parameter creator
 * @export
 */
export const ImportersPulpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for PulpImporters.
         * @summary Delete a pulp importer
         * @param {string} pulpImporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpImporterHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            if (pulpImporterHref === null || pulpImporterHref === undefined) {
                throw new RequiredError('pulpImporterHref','Required parameter pulpImporterHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, encodeURIComponent(String(pulpImporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Create a pulp importer
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpImporter: PulpImporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporter' is not null or undefined
            if (pulpImporter === null || pulpImporter === undefined) {
                throw new RequiredError('pulpImporter','Required parameter pulpImporter was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/importers/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpImporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpImporter !== undefined ? pulpImporter : {})
                : (pulpImporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary List pulp importers
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/importers/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PatchedPulpImporter} patchedPulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            if (pulpImporterHref === null || pulpImporterHref === undefined) {
                throw new RequiredError('pulpImporterHref','Required parameter pulpImporterHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedPulpImporter' is not null or undefined
            if (patchedPulpImporter === null || patchedPulpImporter === undefined) {
                throw new RequiredError('patchedPulpImporter','Required parameter patchedPulpImporter was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, encodeURIComponent(String(pulpImporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedPulpImporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedPulpImporter !== undefined ? patchedPulpImporter : {})
                : (patchedPulpImporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Inspect a pulp importer
         * @param {string} pulpImporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpImporterHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            if (pulpImporterHref === null || pulpImporterHref === undefined) {
                throw new RequiredError('pulpImporterHref','Required parameter pulpImporterHref was null or undefined when calling read.');
            }
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, encodeURIComponent(String(pulpImporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (pulpImporterHref: string, pulpImporter: PulpImporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            if (pulpImporterHref === null || pulpImporterHref === undefined) {
                throw new RequiredError('pulpImporterHref','Required parameter pulpImporterHref was null or undefined when calling update.');
            }
            // verify required parameter 'pulpImporter' is not null or undefined
            if (pulpImporter === null || pulpImporter === undefined) {
                throw new RequiredError('pulpImporter','Required parameter pulpImporter was null or undefined when calling update.');
            }
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, encodeURIComponent(String(pulpImporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pulpImporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pulpImporter !== undefined ? pulpImporter : {})
                : (pulpImporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportersPulpApi - functional programming interface
 * @export
 */
export const ImportersPulpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for PulpImporters.
         * @summary Delete a pulp importer
         * @param {string} pulpImporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpImporterHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImportersPulpApiAxiosParamCreator(configuration)._delete(pulpImporterHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Create a pulp importer
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpImporter: PulpImporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await ImportersPulpApiAxiosParamCreator(configuration).create(pulpImporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary List pulp importers
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPulpImporterResponseList>> {
            const localVarAxiosArgs = await ImportersPulpApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PatchedPulpImporter} patchedPulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await ImportersPulpApiAxiosParamCreator(configuration).partialUpdate(pulpImporterHref, patchedPulpImporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Inspect a pulp importer
         * @param {string} pulpImporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpImporterHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await ImportersPulpApiAxiosParamCreator(configuration).read(pulpImporterHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(pulpImporterHref: string, pulpImporter: PulpImporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await ImportersPulpApiAxiosParamCreator(configuration).update(pulpImporterHref, pulpImporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImportersPulpApi - factory interface
 * @export
 */
export const ImportersPulpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for PulpImporters.
         * @summary Delete a pulp importer
         * @param {string} pulpImporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpImporterHref: string, options?: any): AxiosPromise<void> {
            return ImportersPulpApiFp(configuration)._delete(pulpImporterHref, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Create a pulp importer
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpImporter: PulpImporter, options?: any): AxiosPromise<PulpImporterResponse> {
            return ImportersPulpApiFp(configuration).create(pulpImporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary List pulp importers
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPulpImporterResponseList> {
            return ImportersPulpApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PatchedPulpImporter} patchedPulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options?: any): AxiosPromise<PulpImporterResponse> {
            return ImportersPulpApiFp(configuration).partialUpdate(pulpImporterHref, patchedPulpImporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Inspect a pulp importer
         * @param {string} pulpImporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpImporterHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PulpImporterResponse> {
            return ImportersPulpApiFp(configuration).read(pulpImporterHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(pulpImporterHref: string, pulpImporter: PulpImporter, options?: any): AxiosPromise<PulpImporterResponse> {
            return ImportersPulpApiFp(configuration).update(pulpImporterHref, pulpImporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportersPulpApi - object-oriented interface
 * @export
 * @class ImportersPulpApi
 * @extends {BaseAPI}
 */
export class ImportersPulpApi extends BaseAPI {
    /**
     * ViewSet for PulpImporters.
     * @summary Delete a pulp importer
     * @param {string} pulpImporterHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public _delete(pulpImporterHref: string, options?: any) {
        return ImportersPulpApiFp(this.configuration)._delete(pulpImporterHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Create a pulp importer
     * @param {PulpImporter} pulpImporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public create(pulpImporter: PulpImporter, options?: any) {
        return ImportersPulpApiFp(this.configuration).create(pulpImporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary List pulp importers
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersPulpApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Update a pulp importer
     * @param {string} pulpImporterHref 
     * @param {PatchedPulpImporter} patchedPulpImporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public partialUpdate(pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options?: any) {
        return ImportersPulpApiFp(this.configuration).partialUpdate(pulpImporterHref, patchedPulpImporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Inspect a pulp importer
     * @param {string} pulpImporterHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public read(pulpImporterHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersPulpApiFp(this.configuration).read(pulpImporterHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Update a pulp importer
     * @param {string} pulpImporterHref 
     * @param {PulpImporter} pulpImporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public update(pulpImporterHref: string, pulpImporter: PulpImporter, options?: any) {
        return ImportersPulpApiFp(this.configuration).update(pulpImporterHref, pulpImporter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrphansApi - axios parameter creator
 * @export
 */
export const OrphansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task that deletes allorphaned content and artifacts.
         * @summary Delete orphans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/orphans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrphansApi - functional programming interface
 * @export
 */
export const OrphansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task that deletes allorphaned content and artifacts.
         * @summary Delete orphans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await OrphansApiAxiosParamCreator(configuration)._delete(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrphansApi - factory interface
 * @export
 */
export const OrphansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous task that deletes allorphaned content and artifacts.
         * @summary Delete orphans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options?: any): AxiosPromise<AsyncOperationResponse> {
            return OrphansApiFp(configuration)._delete(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrphansApi - object-oriented interface
 * @export
 * @class OrphansApi
 * @extends {BaseAPI}
 */
export class OrphansApi extends BaseAPI {
    /**
     * Trigger an asynchronous task that deletes allorphaned content and artifacts.
     * @summary Delete orphans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrphansApi
     */
    public _delete(options?: any) {
        return OrphansApiFp(this.configuration)._delete(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepairApi - axios parameter creator
 * @export
 */
export const RepairApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
         * @summary Repair Artifact Storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repair/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepairApi - functional programming interface
 * @export
 */
export const RepairApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
         * @summary Repair Artifact Storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepairApiAxiosParamCreator(configuration).post(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepairApi - factory interface
 * @export
 */
export const RepairApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
         * @summary Repair Artifact Storage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepairApiFp(configuration).post(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepairApi - object-oriented interface
 * @export
 * @class RepairApi
 * @extends {BaseAPI}
 */
export class RepairApi extends BaseAPI {
    /**
     * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
     * @summary Repair Artifact Storage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepairApi
     */
    public post(options?: any) {
        return RepairApiFp(this.configuration).post(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all repositories.
         * @summary List repositories
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repositories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all repositories.
         * @summary List repositories
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryResponseList>> {
            const localVarAxiosArgs = await RepositoriesApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Endpoint to list all repositories.
         * @summary List repositories
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRepositoryResponseList> {
            return RepositoriesApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI {
    /**
     * Endpoint to list all repositories.
     * @summary List repositories
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] pulp_label_select
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SigningServicesApi - axios parameter creator
 * @export
 */
export const SigningServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary List signing services
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/signing-services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary Inspect a signing service
         * @param {string} signingServiceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (signingServiceHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signingServiceHref' is not null or undefined
            if (signingServiceHref === null || signingServiceHref === undefined) {
                throw new RequiredError('signingServiceHref','Required parameter signingServiceHref was null or undefined when calling read.');
            }
            const localVarPath = `{signing_service_href}`
                .replace(`{${"signing_service_href"}}`, encodeURIComponent(String(signingServiceHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigningServicesApi - functional programming interface
 * @export
 */
export const SigningServicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary List signing services
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSigningServiceResponseList>> {
            const localVarAxiosArgs = await SigningServicesApiAxiosParamCreator(configuration).list(limit, name, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary Inspect a signing service
         * @param {string} signingServiceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(signingServiceHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningServiceResponse>> {
            const localVarAxiosArgs = await SigningServicesApiAxiosParamCreator(configuration).read(signingServiceHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SigningServicesApi - factory interface
 * @export
 */
export const SigningServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary List signing services
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedSigningServiceResponseList> {
            return SigningServicesApiFp(configuration).list(limit, name, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary Inspect a signing service
         * @param {string} signingServiceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(signingServiceHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<SigningServiceResponse> {
            return SigningServicesApiFp(configuration).read(signingServiceHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigningServicesApi - object-oriented interface
 * @export
 * @class SigningServicesApi
 * @extends {BaseAPI}
 */
export class SigningServicesApi extends BaseAPI {
    /**
     * A ViewSet that supports browsing of existing signing services.
     * @summary List signing services
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningServicesApi
     */
    public list(limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return SigningServicesApiFp(this.configuration).list(limit, name, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet that supports browsing of existing signing services.
     * @summary Inspect a signing service
     * @param {string} signingServiceHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningServicesApi
     */
    public read(signingServiceHref: string, fields?: string, excludeFields?: string, options?: any) {
        return SigningServicesApiFp(this.configuration).read(signingServiceHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns app information including the version of pulpcore and loaded pulp plugins, known workers, database connection status, and messaging connection status
         * @summary Inspect status of Pulp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusRead: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns app information including the version of pulpcore and loaded pulp plugins, known workers, database connection status, and messaging connection status
         * @summary Inspect status of Pulp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusRead(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await StatusApiAxiosParamCreator(configuration).statusRead(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns app information including the version of pulpcore and loaded pulp plugins, known workers, database connection status, and messaging connection status
         * @summary Inspect status of Pulp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusRead(options?: any): AxiosPromise<StatusResponse> {
            return StatusApiFp(configuration).statusRead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns app information including the version of pulpcore and loaded pulp plugins, known workers, database connection status, and messaging connection status
     * @summary Inspect status of Pulp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusRead(options?: any) {
        return StatusApiFp(this.configuration).statusRead(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskGroupsApi - axios parameter creator
 * @export
 */
export const TaskGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List task groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/task-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task group
         * @param {string} taskGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (taskGroupHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskGroupHref' is not null or undefined
            if (taskGroupHref === null || taskGroupHref === undefined) {
                throw new RequiredError('taskGroupHref','Required parameter taskGroupHref was null or undefined when calling read.');
            }
            const localVarPath = `{task_group_href}`
                .replace(`{${"task_group_href"}}`, encodeURIComponent(String(taskGroupHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskGroupsApi - functional programming interface
 * @export
 */
export const TaskGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List task groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaskGroupResponseList>> {
            const localVarAxiosArgs = await TaskGroupsApiAxiosParamCreator(configuration).list(limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task group
         * @param {string} taskGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(taskGroupHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGroupResponse>> {
            const localVarAxiosArgs = await TaskGroupsApiAxiosParamCreator(configuration).read(taskGroupHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TaskGroupsApi - factory interface
 * @export
 */
export const TaskGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List task groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedTaskGroupResponseList> {
            return TaskGroupsApiFp(configuration).list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task group
         * @param {string} taskGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(taskGroupHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<TaskGroupResponse> {
            return TaskGroupsApiFp(configuration).read(taskGroupHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskGroupsApi - object-oriented interface
 * @export
 * @class TaskGroupsApi
 * @extends {BaseAPI}
 */
export class TaskGroupsApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List task groups
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGroupsApi
     */
    public list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return TaskGroupsApiFp(this.configuration).list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect a task group
     * @param {string} taskGroupHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGroupsApi
     */
    public read(taskGroupHref: string, fields?: string, excludeFields?: string, options?: any) {
        return TaskGroupsApiFp(this.configuration).read(taskGroupHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Delete a task
         * @param {string} taskHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (taskHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskHref' is not null or undefined
            if (taskHref === null || taskHref === undefined) {
                throw new RequiredError('taskHref','Required parameter taskHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{task_href}`
                .replace(`{${"task_href"}}`, encodeURIComponent(String(taskHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List tasks
         * @param {string} [childTasks] child_tasks
         * @param {string} [createdResources] created_resources
         * @param {string} [finishedAt] finished_at
         * @param {string} [finishedAtGt] finished_at__gt
         * @param {string} [finishedAtGte] finished_at__gte
         * @param {string} [finishedAtLt] finished_at__lt
         * @param {string} [finishedAtLte] finished_at__lte
         * @param {string} [finishedAtRange] finished_at__range
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [parentTask] parent_task
         * @param {string} [reservedResourcesRecord] reserved_resources_record
         * @param {string} [startedAt] started_at
         * @param {string} [startedAtGt] started_at__gt
         * @param {string} [startedAtGte] started_at__gte
         * @param {string} [startedAtLt] started_at__lt
         * @param {string} [startedAtLte] started_at__lte
         * @param {string} [startedAtRange] started_at__range
         * @param {string} [state] state
         * @param {string} [stateIn] state__in
         * @param {string} [taskGroup] task_group
         * @param {string} [worker] worker
         * @param {string} [workerIn] worker__in
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: string, limit?: number, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: string, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: string, state?: string, stateIn?: string, taskGroup?: string, worker?: string, workerIn?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (childTasks !== undefined) {
                localVarQueryParameter['child_tasks'] = childTasks;
            }

            if (createdResources !== undefined) {
                localVarQueryParameter['created_resources'] = createdResources;
            }

            if (finishedAt !== undefined) {
                localVarQueryParameter['finished_at'] = finishedAt;
            }

            if (finishedAtGt !== undefined) {
                localVarQueryParameter['finished_at__gt'] = finishedAtGt;
            }

            if (finishedAtGte !== undefined) {
                localVarQueryParameter['finished_at__gte'] = finishedAtGte;
            }

            if (finishedAtLt !== undefined) {
                localVarQueryParameter['finished_at__lt'] = finishedAtLt;
            }

            if (finishedAtLte !== undefined) {
                localVarQueryParameter['finished_at__lte'] = finishedAtLte;
            }

            if (finishedAtRange !== undefined) {
                localVarQueryParameter['finished_at__range'] = finishedAtRange;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (parentTask !== undefined) {
                localVarQueryParameter['parent_task'] = parentTask;
            }

            if (reservedResourcesRecord !== undefined) {
                localVarQueryParameter['reserved_resources_record'] = reservedResourcesRecord;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['started_at'] = startedAt;
            }

            if (startedAtGt !== undefined) {
                localVarQueryParameter['started_at__gt'] = startedAtGt;
            }

            if (startedAtGte !== undefined) {
                localVarQueryParameter['started_at__gte'] = startedAtGte;
            }

            if (startedAtLt !== undefined) {
                localVarQueryParameter['started_at__lt'] = startedAtLt;
            }

            if (startedAtLte !== undefined) {
                localVarQueryParameter['started_at__lte'] = startedAtLte;
            }

            if (startedAtRange !== undefined) {
                localVarQueryParameter['started_at__range'] = startedAtRange;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (stateIn !== undefined) {
                localVarQueryParameter['state__in'] = stateIn;
            }

            if (taskGroup !== undefined) {
                localVarQueryParameter['task_group'] = taskGroup;
            }

            if (worker !== undefined) {
                localVarQueryParameter['worker'] = worker;
            }

            if (workerIn !== undefined) {
                localVarQueryParameter['worker__in'] = workerIn;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task
         * @param {string} taskHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (taskHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskHref' is not null or undefined
            if (taskHref === null || taskHref === undefined) {
                throw new RequiredError('taskHref','Required parameter taskHref was null or undefined when calling read.');
            }

            // remove encodeURIComponent by hand since we don't want taskHref encoded
            const localVarPath = `{task_href}`
                .replace(`{${"task_href"}}`, String(taskHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation cancels a task.
         * @summary Cancel a task
         * @param {string} taskHref 
         * @param {PatchedTaskCancel} patchedTaskCancel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCancel: async (taskHref: string, patchedTaskCancel: PatchedTaskCancel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskHref' is not null or undefined
            if (taskHref === null || taskHref === undefined) {
                throw new RequiredError('taskHref','Required parameter taskHref was null or undefined when calling tasksCancel.');
            }
            // verify required parameter 'patchedTaskCancel' is not null or undefined
            if (patchedTaskCancel === null || patchedTaskCancel === undefined) {
                throw new RequiredError('patchedTaskCancel','Required parameter patchedTaskCancel was null or undefined when calling tasksCancel.');
            }
            const localVarPath = `{task_href}`
                .replace(`{${"task_href"}}`, encodeURIComponent(String(taskHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedTaskCancel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedTaskCancel !== undefined ? patchedTaskCancel : {})
                : (patchedTaskCancel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Delete a task
         * @param {string} taskHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(taskHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration)._delete(taskHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List tasks
         * @param {string} [childTasks] child_tasks
         * @param {string} [createdResources] created_resources
         * @param {string} [finishedAt] finished_at
         * @param {string} [finishedAtGt] finished_at__gt
         * @param {string} [finishedAtGte] finished_at__gte
         * @param {string} [finishedAtLt] finished_at__lt
         * @param {string} [finishedAtLte] finished_at__lte
         * @param {string} [finishedAtRange] finished_at__range
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [parentTask] parent_task
         * @param {string} [reservedResourcesRecord] reserved_resources_record
         * @param {string} [startedAt] started_at
         * @param {string} [startedAtGt] started_at__gt
         * @param {string} [startedAtGte] started_at__gte
         * @param {string} [startedAtLt] started_at__lt
         * @param {string} [startedAtLte] started_at__lte
         * @param {string} [startedAtRange] started_at__range
         * @param {string} [state] state
         * @param {string} [stateIn] state__in
         * @param {string} [taskGroup] task_group
         * @param {string} [worker] worker
         * @param {string} [workerIn] worker__in
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: string, limit?: number, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: string, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: string, state?: string, stateIn?: string, taskGroup?: string, worker?: string, workerIn?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaskResponseList>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).list(childTasks, createdResources, finishedAt, finishedAtGt, finishedAtGte, finishedAtLt, finishedAtLte, finishedAtRange, limit, name, nameContains, offset, ordering, parentTask, reservedResourcesRecord, startedAt, startedAtGt, startedAtGte, startedAtLt, startedAtLte, startedAtRange, state, stateIn, taskGroup, worker, workerIn, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task
         * @param {string} taskHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(taskHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).read(taskHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This operation cancels a task.
         * @summary Cancel a task
         * @param {string} taskHref 
         * @param {PatchedTaskCancel} patchedTaskCancel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCancel(taskHref: string, patchedTaskCancel: PatchedTaskCancel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksCancel(taskHref, patchedTaskCancel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Delete a task
         * @param {string} taskHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(taskHref: string, options?: any): AxiosPromise<void> {
            return TasksApiFp(configuration)._delete(taskHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List tasks
         * @param {string} [childTasks] child_tasks
         * @param {string} [createdResources] created_resources
         * @param {string} [finishedAt] finished_at
         * @param {string} [finishedAtGt] finished_at__gt
         * @param {string} [finishedAtGte] finished_at__gte
         * @param {string} [finishedAtLt] finished_at__lt
         * @param {string} [finishedAtLte] finished_at__lte
         * @param {string} [finishedAtRange] finished_at__range
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [parentTask] parent_task
         * @param {string} [reservedResourcesRecord] reserved_resources_record
         * @param {string} [startedAt] started_at
         * @param {string} [startedAtGt] started_at__gt
         * @param {string} [startedAtGte] started_at__gte
         * @param {string} [startedAtLt] started_at__lt
         * @param {string} [startedAtLte] started_at__lte
         * @param {string} [startedAtRange] started_at__range
         * @param {string} [state] state
         * @param {string} [stateIn] state__in
         * @param {string} [taskGroup] task_group
         * @param {string} [worker] worker
         * @param {string} [workerIn] worker__in
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: string, limit?: number, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: string, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: string, state?: string, stateIn?: string, taskGroup?: string, worker?: string, workerIn?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedTaskResponseList> {
            return TasksApiFp(configuration).list(childTasks, createdResources, finishedAt, finishedAtGt, finishedAtGte, finishedAtLt, finishedAtLte, finishedAtRange, limit, name, nameContains, offset, ordering, parentTask, reservedResourcesRecord, startedAt, startedAtGt, startedAtGte, startedAtLt, startedAtLte, startedAtRange, state, stateIn, taskGroup, worker, workerIn, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task
         * @param {string} taskHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(taskHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<TaskResponse> {
            return TasksApiFp(configuration).read(taskHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation cancels a task.
         * @summary Cancel a task
         * @param {string} taskHref 
         * @param {PatchedTaskCancel} patchedTaskCancel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCancel(taskHref: string, patchedTaskCancel: PatchedTaskCancel, options?: any): AxiosPromise<TaskResponse> {
            return TasksApiFp(configuration).tasksCancel(taskHref, patchedTaskCancel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Delete a task
     * @param {string} taskHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public _delete(taskHref: string, options?: any) {
        return TasksApiFp(this.configuration)._delete(taskHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List tasks
     * @param {string} [childTasks] child_tasks
     * @param {string} [createdResources] created_resources
     * @param {string} [finishedAt] finished_at
     * @param {string} [finishedAtGt] finished_at__gt
     * @param {string} [finishedAtGte] finished_at__gte
     * @param {string} [finishedAtLt] finished_at__lt
     * @param {string} [finishedAtLte] finished_at__lte
     * @param {string} [finishedAtRange] finished_at__range
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [parentTask] parent_task
     * @param {string} [reservedResourcesRecord] reserved_resources_record
     * @param {string} [startedAt] started_at
     * @param {string} [startedAtGt] started_at__gt
     * @param {string} [startedAtGte] started_at__gte
     * @param {string} [startedAtLt] started_at__lt
     * @param {string} [startedAtLte] started_at__lte
     * @param {string} [startedAtRange] started_at__range
     * @param {string} [state] state
     * @param {string} [stateIn] state__in
     * @param {string} [taskGroup] task_group
     * @param {string} [worker] worker
     * @param {string} [workerIn] worker__in
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public list(childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: string, limit?: number, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: string, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: string, state?: string, stateIn?: string, taskGroup?: string, worker?: string, workerIn?: string, fields?: string, excludeFields?: string, options?: any) {
        return TasksApiFp(this.configuration).list(childTasks, createdResources, finishedAt, finishedAtGt, finishedAtGte, finishedAtLt, finishedAtLte, finishedAtRange, limit, name, nameContains, offset, ordering, parentTask, reservedResourcesRecord, startedAt, startedAtGt, startedAtGte, startedAtLt, startedAtLte, startedAtRange, state, stateIn, taskGroup, worker, workerIn, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect a task
     * @param {string} taskHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public read(taskHref: string, fields?: string, excludeFields?: string, options?: any) {
        return TasksApiFp(this.configuration).read(taskHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation cancels a task.
     * @summary Cancel a task
     * @param {string} taskHref 
     * @param {PatchedTaskCancel} patchedTaskCancel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCancel(taskHref: string, patchedTaskCancel: PatchedTaskCancel, options?: any) {
        return TasksApiFp(this.configuration).tasksCancel(taskHref, patchedTaskCancel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View for chunked uploads.
         * @summary Delete an upload
         * @param {string} uploadHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (uploadHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadHref' is not null or undefined
            if (uploadHref === null || uploadHref === undefined) {
                throw new RequiredError('uploadHref','Required parameter uploadHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{upload_href}`
                .replace(`{${"upload_href"}}`, encodeURIComponent(String(uploadHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
         * @summary Finish an Upload
         * @param {string} uploadHref 
         * @param {UploadCommit} uploadCommit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: async (uploadHref: string, uploadCommit: UploadCommit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadHref' is not null or undefined
            if (uploadHref === null || uploadHref === undefined) {
                throw new RequiredError('uploadHref','Required parameter uploadHref was null or undefined when calling commit.');
            }
            // verify required parameter 'uploadCommit' is not null or undefined
            if (uploadCommit === null || uploadCommit === undefined) {
                throw new RequiredError('uploadCommit','Required parameter uploadCommit was null or undefined when calling commit.');
            }
            const localVarPath = `{upload_href}commit/`
                .replace(`{${"upload_href"}}`, encodeURIComponent(String(uploadHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof uploadCommit !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(uploadCommit !== undefined ? uploadCommit : {})
                : (uploadCommit || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * View for chunked uploads.
         * @summary Create an upload
         * @param {Upload} upload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (upload: Upload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'upload' is not null or undefined
            if (upload === null || upload === undefined) {
                throw new RequiredError('upload','Required parameter upload was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/uploads/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof upload !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(upload !== undefined ? upload : {})
                : (upload || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * View for chunked uploads.
         * @summary List uploads
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/uploads/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * View for chunked uploads.
         * @summary Inspect an upload
         * @param {string} uploadHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (uploadHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadHref' is not null or undefined
            if (uploadHref === null || uploadHref === undefined) {
                throw new RequiredError('uploadHref','Required parameter uploadHref was null or undefined when calling read.');
            }
            const localVarPath = `{upload_href}`
                .replace(`{${"upload_href"}}`, encodeURIComponent(String(uploadHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a chunk for an upload.
         * @summary Upload a file chunk
         * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
         * @param {string} uploadHref 
         * @param {any} file A chunk of the uploaded file.
         * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (contentRange: string, uploadHref: string, file: any, sha256?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentRange' is not null or undefined
            if (contentRange === null || contentRange === undefined) {
                throw new RequiredError('contentRange','Required parameter contentRange was null or undefined when calling update.');
            }
            // verify required parameter 'uploadHref' is not null or undefined
            if (uploadHref === null || uploadHref === undefined) {
                throw new RequiredError('uploadHref','Required parameter uploadHref was null or undefined when calling update.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling update.');
            }
            const localVarPath = `{upload_href}`
                .replace(`{${"upload_href"}}`, encodeURIComponent(String(uploadHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (contentRange !== undefined && contentRange !== null) {
                localVarHeaderParameter['Content-Range'] = String(contentRange);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (sha256 !== undefined) { 
                localVarFormParams.append('sha256', sha256 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * View for chunked uploads.
         * @summary Delete an upload
         * @param {string} uploadHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(uploadHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration)._delete(uploadHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
         * @summary Finish an Upload
         * @param {string} uploadHref 
         * @param {UploadCommit} uploadCommit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commit(uploadHref: string, uploadCommit: UploadCommit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).commit(uploadHref, uploadCommit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * View for chunked uploads.
         * @summary Create an upload
         * @param {Upload} upload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(upload: Upload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadResponse>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).create(upload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * View for chunked uploads.
         * @summary List uploads
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUploadResponseList>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).list(limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * View for chunked uploads.
         * @summary Inspect an upload
         * @param {string} uploadHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(uploadHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadDetailResponse>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).read(uploadHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a chunk for an upload.
         * @summary Upload a file chunk
         * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
         * @param {string} uploadHref 
         * @param {any} file A chunk of the uploaded file.
         * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(contentRange: string, uploadHref: string, file: any, sha256?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadResponse>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).update(contentRange, uploadHref, file, sha256, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * View for chunked uploads.
         * @summary Delete an upload
         * @param {string} uploadHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(uploadHref: string, options?: any): AxiosPromise<void> {
            return UploadsApiFp(configuration)._delete(uploadHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
         * @summary Finish an Upload
         * @param {string} uploadHref 
         * @param {UploadCommit} uploadCommit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(uploadHref: string, uploadCommit: UploadCommit, options?: any): AxiosPromise<AsyncOperationResponse> {
            return UploadsApiFp(configuration).commit(uploadHref, uploadCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * View for chunked uploads.
         * @summary Create an upload
         * @param {Upload} upload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(upload: Upload, options?: any): AxiosPromise<UploadResponse> {
            return UploadsApiFp(configuration).create(upload, options).then((request) => request(axios, basePath));
        },
        /**
         * View for chunked uploads.
         * @summary List uploads
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedUploadResponseList> {
            return UploadsApiFp(configuration).list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * View for chunked uploads.
         * @summary Inspect an upload
         * @param {string} uploadHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(uploadHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<UploadDetailResponse> {
            return UploadsApiFp(configuration).read(uploadHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a chunk for an upload.
         * @summary Upload a file chunk
         * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
         * @param {string} uploadHref 
         * @param {any} file A chunk of the uploaded file.
         * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(contentRange: string, uploadHref: string, file: any, sha256?: string, options?: any): AxiosPromise<UploadResponse> {
            return UploadsApiFp(configuration).update(contentRange, uploadHref, file, sha256, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * View for chunked uploads.
     * @summary Delete an upload
     * @param {string} uploadHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public _delete(uploadHref: string, options?: any) {
        return UploadsApiFp(this.configuration)._delete(uploadHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
     * @summary Finish an Upload
     * @param {string} uploadHref 
     * @param {UploadCommit} uploadCommit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public commit(uploadHref: string, uploadCommit: UploadCommit, options?: any) {
        return UploadsApiFp(this.configuration).commit(uploadHref, uploadCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View for chunked uploads.
     * @summary Create an upload
     * @param {Upload} upload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public create(upload: Upload, options?: any) {
        return UploadsApiFp(this.configuration).create(upload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View for chunked uploads.
     * @summary List uploads
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return UploadsApiFp(this.configuration).list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View for chunked uploads.
     * @summary Inspect an upload
     * @param {string} uploadHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public read(uploadHref: string, fields?: string, excludeFields?: string, options?: any) {
        return UploadsApiFp(this.configuration).read(uploadHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a chunk for an upload.
     * @summary Upload a file chunk
     * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
     * @param {string} uploadHref 
     * @param {any} file A chunk of the uploaded file.
     * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public update(contentRange: string, uploadHref: string, file: any, sha256?: string, options?: any) {
        return UploadsApiFp(this.configuration).update(contentRange, uploadHref, file, sha256, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List users
         * @param {string} [email] email
         * @param {string} [emailContains] email__contains
         * @param {string} [emailIcontains] email__icontains
         * @param {string} [emailIexact] email__iexact
         * @param {string} [emailIn] email__in
         * @param {string} [firstName] first_name
         * @param {string} [firstNameContains] first_name__contains
         * @param {string} [firstNameIcontains] first_name__icontains
         * @param {string} [firstNameIexact] first_name__iexact
         * @param {string} [firstNameIn] first_name__in
         * @param {string} [isActive] is_active
         * @param {string} [isStaff] is_staff
         * @param {string} [lastName] last_name
         * @param {string} [lastNameContains] last_name__contains
         * @param {string} [lastNameIcontains] last_name__icontains
         * @param {string} [lastNameIexact] last_name__iexact
         * @param {string} [lastNameIn] last_name__in
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [username] username
         * @param {string} [usernameContains] username__contains
         * @param {string} [usernameIcontains] username__icontains
         * @param {string} [usernameIexact] username__iexact
         * @param {string} [usernameIn] username__in
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: string, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: string, isActive?: string, isStaff?: string, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: string, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (emailContains !== undefined) {
                localVarQueryParameter['email__contains'] = emailContains;
            }

            if (emailIcontains !== undefined) {
                localVarQueryParameter['email__icontains'] = emailIcontains;
            }

            if (emailIexact !== undefined) {
                localVarQueryParameter['email__iexact'] = emailIexact;
            }

            if (emailIn !== undefined) {
                localVarQueryParameter['email__in'] = emailIn;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (firstNameContains !== undefined) {
                localVarQueryParameter['first_name__contains'] = firstNameContains;
            }

            if (firstNameIcontains !== undefined) {
                localVarQueryParameter['first_name__icontains'] = firstNameIcontains;
            }

            if (firstNameIexact !== undefined) {
                localVarQueryParameter['first_name__iexact'] = firstNameIexact;
            }

            if (firstNameIn !== undefined) {
                localVarQueryParameter['first_name__in'] = firstNameIn;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (isStaff !== undefined) {
                localVarQueryParameter['is_staff'] = isStaff;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (lastNameContains !== undefined) {
                localVarQueryParameter['last_name__contains'] = lastNameContains;
            }

            if (lastNameIcontains !== undefined) {
                localVarQueryParameter['last_name__icontains'] = lastNameIcontains;
            }

            if (lastNameIexact !== undefined) {
                localVarQueryParameter['last_name__iexact'] = lastNameIexact;
            }

            if (lastNameIn !== undefined) {
                localVarQueryParameter['last_name__in'] = lastNameIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (usernameContains !== undefined) {
                localVarQueryParameter['username__contains'] = usernameContains;
            }

            if (usernameIcontains !== undefined) {
                localVarQueryParameter['username__icontains'] = usernameIcontains;
            }

            if (usernameIexact !== undefined) {
                localVarQueryParameter['username__iexact'] = usernameIexact;
            }

            if (usernameIn !== undefined) {
                localVarQueryParameter['username__in'] = usernameIn;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List user permissions.
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissions: async (authUserHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authUserHref' is not null or undefined
            if (authUserHref === null || authUserHref === undefined) {
                throw new RequiredError('authUserHref','Required parameter authUserHref was null or undefined when calling permissions.');
            }
            const localVarPath = `{auth_user_href}permissions/`
                .replace(`{${"auth_user_href"}}`, encodeURIComponent(String(authUserHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an user
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authUserHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authUserHref' is not null or undefined
            if (authUserHref === null || authUserHref === undefined) {
                throw new RequiredError('authUserHref','Required parameter authUserHref was null or undefined when calling read.');
            }
            const localVarPath = `{auth_user_href}`
                .replace(`{${"auth_user_href"}}`, encodeURIComponent(String(authUserHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List users
         * @param {string} [email] email
         * @param {string} [emailContains] email__contains
         * @param {string} [emailIcontains] email__icontains
         * @param {string} [emailIexact] email__iexact
         * @param {string} [emailIn] email__in
         * @param {string} [firstName] first_name
         * @param {string} [firstNameContains] first_name__contains
         * @param {string} [firstNameIcontains] first_name__icontains
         * @param {string} [firstNameIexact] first_name__iexact
         * @param {string} [firstNameIn] first_name__in
         * @param {string} [isActive] is_active
         * @param {string} [isStaff] is_staff
         * @param {string} [lastName] last_name
         * @param {string} [lastNameContains] last_name__contains
         * @param {string} [lastNameIcontains] last_name__icontains
         * @param {string} [lastNameIexact] last_name__iexact
         * @param {string} [lastNameIn] last_name__in
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [username] username
         * @param {string} [usernameContains] username__contains
         * @param {string} [usernameIcontains] username__icontains
         * @param {string} [usernameIexact] username__iexact
         * @param {string} [usernameIn] username__in
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: string, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: string, isActive?: string, isStaff?: string, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: string, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponseList>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).list(email, emailContains, emailIcontains, emailIexact, emailIn, firstName, firstNameContains, firstNameIcontains, firstNameIexact, firstNameIn, isActive, isStaff, lastName, lastNameContains, lastNameIcontains, lastNameIexact, lastNameIn, limit, offset, ordering, username, usernameContains, usernameIcontains, usernameIexact, usernameIn, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List user permissions.
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissions(authUserHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).permissions(authUserHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an user
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authUserHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).read(authUserHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List users
         * @param {string} [email] email
         * @param {string} [emailContains] email__contains
         * @param {string} [emailIcontains] email__icontains
         * @param {string} [emailIexact] email__iexact
         * @param {string} [emailIn] email__in
         * @param {string} [firstName] first_name
         * @param {string} [firstNameContains] first_name__contains
         * @param {string} [firstNameIcontains] first_name__icontains
         * @param {string} [firstNameIexact] first_name__iexact
         * @param {string} [firstNameIn] first_name__in
         * @param {string} [isActive] is_active
         * @param {string} [isStaff] is_staff
         * @param {string} [lastName] last_name
         * @param {string} [lastNameContains] last_name__contains
         * @param {string} [lastNameIcontains] last_name__icontains
         * @param {string} [lastNameIexact] last_name__iexact
         * @param {string} [lastNameIn] last_name__in
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [username] username
         * @param {string} [usernameContains] username__contains
         * @param {string} [usernameIcontains] username__icontains
         * @param {string} [usernameIexact] username__iexact
         * @param {string} [usernameIn] username__in
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: string, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: string, isActive?: string, isStaff?: string, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: string, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedUserResponseList> {
            return UsersApiFp(configuration).list(email, emailContains, emailIcontains, emailIexact, emailIn, firstName, firstNameContains, firstNameIcontains, firstNameIexact, firstNameIn, isActive, isStaff, lastName, lastNameContains, lastNameIcontains, lastNameIexact, lastNameIn, limit, offset, ordering, username, usernameContains, usernameIcontains, usernameIexact, usernameIn, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * List user permissions.
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissions(authUserHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PermissionResponse> {
            return UsersApiFp(configuration).permissions(authUserHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an user
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authUserHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<UserResponse> {
            return UsersApiFp(configuration).read(authUserHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary List users
     * @param {string} [email] email
     * @param {string} [emailContains] email__contains
     * @param {string} [emailIcontains] email__icontains
     * @param {string} [emailIexact] email__iexact
     * @param {string} [emailIn] email__in
     * @param {string} [firstName] first_name
     * @param {string} [firstNameContains] first_name__contains
     * @param {string} [firstNameIcontains] first_name__icontains
     * @param {string} [firstNameIexact] first_name__iexact
     * @param {string} [firstNameIn] first_name__in
     * @param {string} [isActive] is_active
     * @param {string} [isStaff] is_staff
     * @param {string} [lastName] last_name
     * @param {string} [lastNameContains] last_name__contains
     * @param {string} [lastNameIcontains] last_name__icontains
     * @param {string} [lastNameIexact] last_name__iexact
     * @param {string} [lastNameIn] last_name__in
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [username] username
     * @param {string} [usernameContains] username__contains
     * @param {string} [usernameIcontains] username__icontains
     * @param {string} [usernameIexact] username__iexact
     * @param {string} [usernameIn] username__in
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public list(email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: string, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: string, isActive?: string, isStaff?: string, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: string, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: string, fields?: string, excludeFields?: string, options?: any) {
        return UsersApiFp(this.configuration).list(email, emailContains, emailIcontains, emailIexact, emailIn, firstName, firstNameContains, firstNameIcontains, firstNameIexact, firstNameIn, isActive, isStaff, lastName, lastNameContains, lastNameIcontains, lastNameIexact, lastNameIn, limit, offset, ordering, username, usernameContains, usernameIcontains, usernameIexact, usernameIn, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user permissions.
     * @param {string} authUserHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public permissions(authUserHref: string, fields?: string, excludeFields?: string, options?: any) {
        return UsersApiFp(this.configuration).permissions(authUserHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Inspect an user
     * @param {string} authUserHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public read(authUserHref: string, fields?: string, excludeFields?: string, options?: any) {
        return UsersApiFp(this.configuration).read(authUserHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkersApi - axios parameter creator
 * @export
 */
export const WorkersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List workers
         * @param {string} [lastHeartbeat] last_heartbeat
         * @param {string} [lastHeartbeatGt] last_heartbeat__gt
         * @param {string} [lastHeartbeatGte] last_heartbeat__gte
         * @param {string} [lastHeartbeatLt] last_heartbeat__lt
         * @param {string} [lastHeartbeatLte] last_heartbeat__lte
         * @param {string} [lastHeartbeatRange] last_heartbeat__range
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [missing] missing
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [online] online
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: string, limit?: number, missing?: string, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, online?: string, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/workers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (lastHeartbeat !== undefined) {
                localVarQueryParameter['last_heartbeat'] = lastHeartbeat;
            }

            if (lastHeartbeatGt !== undefined) {
                localVarQueryParameter['last_heartbeat__gt'] = lastHeartbeatGt;
            }

            if (lastHeartbeatGte !== undefined) {
                localVarQueryParameter['last_heartbeat__gte'] = lastHeartbeatGte;
            }

            if (lastHeartbeatLt !== undefined) {
                localVarQueryParameter['last_heartbeat__lt'] = lastHeartbeatLt;
            }

            if (lastHeartbeatLte !== undefined) {
                localVarQueryParameter['last_heartbeat__lte'] = lastHeartbeatLte;
            }

            if (lastHeartbeatRange !== undefined) {
                localVarQueryParameter['last_heartbeat__range'] = lastHeartbeatRange;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (missing !== undefined) {
                localVarQueryParameter['missing'] = missing;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (online !== undefined) {
                localVarQueryParameter['online'] = online;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a worker
         * @param {string} workerHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (workerHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerHref' is not null or undefined
            if (workerHref === null || workerHref === undefined) {
                throw new RequiredError('workerHref','Required parameter workerHref was null or undefined when calling read.');
            }
            const localVarPath = `{worker_href}`
                .replace(`{${"worker_href"}}`, encodeURIComponent(String(workerHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkersApi - functional programming interface
 * @export
 */
export const WorkersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List workers
         * @param {string} [lastHeartbeat] last_heartbeat
         * @param {string} [lastHeartbeatGt] last_heartbeat__gt
         * @param {string} [lastHeartbeatGte] last_heartbeat__gte
         * @param {string} [lastHeartbeatLt] last_heartbeat__lt
         * @param {string} [lastHeartbeatLte] last_heartbeat__lte
         * @param {string} [lastHeartbeatRange] last_heartbeat__range
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [missing] missing
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [online] online
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: string, limit?: number, missing?: string, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, online?: string, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkerResponseList>> {
            const localVarAxiosArgs = await WorkersApiAxiosParamCreator(configuration).list(lastHeartbeat, lastHeartbeatGt, lastHeartbeatGte, lastHeartbeatLt, lastHeartbeatLte, lastHeartbeatRange, limit, missing, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, online, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a worker
         * @param {string} workerHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(workerHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerResponse>> {
            const localVarAxiosArgs = await WorkersApiAxiosParamCreator(configuration).read(workerHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkersApi - factory interface
 * @export
 */
export const WorkersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List workers
         * @param {string} [lastHeartbeat] last_heartbeat
         * @param {string} [lastHeartbeatGt] last_heartbeat__gt
         * @param {string} [lastHeartbeatGte] last_heartbeat__gte
         * @param {string} [lastHeartbeatLt] last_heartbeat__lt
         * @param {string} [lastHeartbeatLte] last_heartbeat__lte
         * @param {string} [lastHeartbeatRange] last_heartbeat__range
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [missing] missing
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [online] online
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: string, limit?: number, missing?: string, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, online?: string, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedWorkerResponseList> {
            return WorkersApiFp(configuration).list(lastHeartbeat, lastHeartbeatGt, lastHeartbeatGte, lastHeartbeatLt, lastHeartbeatLte, lastHeartbeatRange, limit, missing, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, online, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a worker
         * @param {string} workerHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(workerHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<WorkerResponse> {
            return WorkersApiFp(configuration).read(workerHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkersApi - object-oriented interface
 * @export
 * @class WorkersApi
 * @extends {BaseAPI}
 */
export class WorkersApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List workers
     * @param {string} [lastHeartbeat] last_heartbeat
     * @param {string} [lastHeartbeatGt] last_heartbeat__gt
     * @param {string} [lastHeartbeatGte] last_heartbeat__gte
     * @param {string} [lastHeartbeatLt] last_heartbeat__lt
     * @param {string} [lastHeartbeatLte] last_heartbeat__lte
     * @param {string} [lastHeartbeatRange] last_heartbeat__range
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [missing] missing
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [online] online
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersApi
     */
    public list(lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: string, limit?: number, missing?: string, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, online?: string, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return WorkersApiFp(this.configuration).list(lastHeartbeat, lastHeartbeatGt, lastHeartbeatGte, lastHeartbeatLt, lastHeartbeatLte, lastHeartbeatRange, limit, missing, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, online, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect a worker
     * @param {string} workerHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersApi
     */
    public read(workerHref: string, fields?: string, excludeFields?: string, options?: any) {
        return WorkersApiFp(this.configuration).read(workerHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


