/* tslint:disable */
/* eslint-disable */
/**
 * Pulp 3 API
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * The version of the OpenAPI document: v3
 * Contact: pulp-list@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Serializer for asynchronous operations.
 * @export
 * @interface AsyncOperationResponse
 */
export interface AsyncOperationResponse {
    /**
     * The href of the task.
     * @type {string}
     * @memberof AsyncOperationResponse
     */
    task: string;
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummary
 */
export interface ContentSummary {
    /**
     * 
     * @type {object}
     * @memberof ContentSummary
     */
    added: object;
    /**
     * 
     * @type {object}
     * @memberof ContentSummary
     */
    removed: object;
    /**
     * 
     * @type {object}
     * @memberof ContentSummary
     */
    present: object;
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummaryResponse
 */
export interface ContentSummaryResponse {
    /**
     * 
     * @type {object}
     * @memberof ContentSummaryResponse
     */
    added: object;
    /**
     * 
     * @type {object}
     * @memberof ContentSummaryResponse
     */
    removed: object;
    /**
     * 
     * @type {object}
     * @memberof ContentSummaryResponse
     */
    present: object;
}
/**
 * Base serializer for Exports.
 * @export
 * @interface ExportResponse
 */
export interface ExportResponse {
    /**
     * 
     * @type {string}
     * @memberof ExportResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ExportResponse
     */
    pulp_created?: string;
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof ExportResponse
     */
    task?: string | null;
    /**
     * Resources that were exported.
     * @type {Array<any>}
     * @memberof ExportResponse
     */
    exported_resources?: Array<any>;
    /**
     * Any additional parameters that were used to create the export.
     * @type {object}
     * @memberof ExportResponse
     */
    params?: object;
}
/**
 * Serializer for File Content.
 * @export
 * @interface FileFileContentResponse
 */
export interface FileFileContentResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileContentResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    pulp_created?: string;
    /**
     * Artifact file representing the physical content
     * @type {string}
     * @memberof FileFileContentResponse
     */
    artifact?: string;
    /**
     * Path where the artifact is located relative to distributions base_path
     * @type {string}
     * @memberof FileFileContentResponse
     */
    relative_path: string;
    /**
     * The MD5 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    md5?: string;
    /**
     * The SHA-1 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha1?: string;
    /**
     * The SHA-224 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha224?: string;
    /**
     * The SHA-256 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha256?: string;
    /**
     * The SHA-384 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha384?: string;
    /**
     * The SHA-512 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha512?: string;
}
/**
 * Serializer for File Distributions.
 * @export
 * @interface FileFileDistribution
 */
export interface FileFileDistribution {
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof FileFileDistribution
     */
    base_path: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof FileFileDistribution
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileDistribution
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof FileFileDistribution
     */
    name: string;
    /**
     * Publication to be served
     * @type {string}
     * @memberof FileFileDistribution
     */
    publication?: string | null;
}
/**
 * Serializer for File Distributions.
 * @export
 * @interface FileFileDistributionResponse
 */
export interface FileFileDistributionResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    pulp_created?: string;
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    base_path: string;
    /**
     * The URL for accessing the publication as defined by this distribution.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    base_url?: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileDistributionResponse
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    name: string;
    /**
     * Publication to be served
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    publication?: string | null;
}
/**
 * Serializer for File file system exporters.
 * @export
 * @interface FileFileFilesystemExporter
 */
export interface FileFileFilesystemExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof FileFileFilesystemExporter
     */
    name: string;
    /**
     * File system location to export to.
     * @type {string}
     * @memberof FileFileFilesystemExporter
     */
    path: string;
}
/**
 * Serializer for File file system exporters.
 * @export
 * @interface FileFileFilesystemExporterResponse
 */
export interface FileFileFilesystemExporterResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileFilesystemExporterResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileFilesystemExporterResponse
     */
    pulp_created?: string;
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof FileFileFilesystemExporterResponse
     */
    name: string;
    /**
     * File system location to export to.
     * @type {string}
     * @memberof FileFileFilesystemExporterResponse
     */
    path: string;
}
/**
 * Serializer for File Publications.
 * @export
 * @interface FileFilePublication
 */
export interface FileFilePublication {
    /**
     * 
     * @type {string}
     * @memberof FileFilePublication
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof FileFilePublication
     */
    repository?: string;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof FileFilePublication
     */
    manifest?: string;
}
/**
 * Serializer for File Publications.
 * @export
 * @interface FileFilePublicationResponse
 */
export interface FileFilePublicationResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    repository?: string;
    /**
     * This publication is currently hosted as defined by these distributions.
     * @type {Array<string>}
     * @memberof FileFilePublicationResponse
     */
    distributions?: Array<string>;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    manifest?: string;
}
/**
 * Serializer for File Remotes.
 * @export
 * @interface FileFileRemote
 */
export interface FileFileRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof FileFileRemote
     */
    name: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof FileFileRemote
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof FileFileRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof FileFileRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof FileFileRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof FileFileRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://user:password@host:port
     * @type {string}
     * @memberof FileFileRemote
     */
    proxy_url?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof FileFileRemote
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof FileFileRemote
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections.
     * @type {number}
     * @memberof FileFileRemote
     */
    download_concurrency?: number;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof FileFileRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof FileFileRemote
     */
    rate_limit?: number | null;
}
/**
 * Serializer for File Remotes.
 * @export
 * @interface FileFileRemoteResponse
 */
export interface FileFileRemoteResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    pulp_created?: string;
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    name: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof FileFileRemoteResponse
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://user:password@host:port
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    proxy_url?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileRemoteResponse
     */
    pulp_labels?: object;
    /**
     * Timestamp of the most recent update of the remote.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    pulp_last_updated?: string;
    /**
     * Total number of simultaneous connections.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    download_concurrency?: number;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof FileFileRemoteResponse
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    sock_read_timeout?: number | null;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    rate_limit?: number | null;
}
/**
 * Serializer for File Repositories.
 * @export
 * @interface FileFileRepository
 */
export interface FileFileRepository {
    /**
     * 
     * @type {object}
     * @memberof FileFileRepository
     */
    pulp_labels?: object;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof FileFileRepository
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof FileFileRepository
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FileFileRepository
     */
    remote?: string | null;
}
/**
 * Serializer for File Repositories.
 * @export
 * @interface FileFileRepositoryResponse
 */
export interface FileFileRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    versions_href?: string;
    /**
     * 
     * @type {object}
     * @memberof FileFileRepositoryResponse
     */
    pulp_labels?: object;
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    latest_version_href?: string;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    remote?: string | null;
}
/**
 * 
 * @export
 * @interface PaginatedExportResponseList
 */
export interface PaginatedExportResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExportResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportResponse>}
     * @memberof PaginatedExportResponseList
     */
    results?: Array<ExportResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedRepositoryVersionResponseList
 */
export interface PaginatedRepositoryVersionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RepositoryVersionResponse>}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    results?: Array<RepositoryVersionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileContentResponseList
 */
export interface PaginatedfileFileContentResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileContentResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileContentResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileContentResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileContentResponse>}
     * @memberof PaginatedfileFileContentResponseList
     */
    results?: Array<FileFileContentResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileDistributionResponseList
 */
export interface PaginatedfileFileDistributionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileDistributionResponse>}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    results?: Array<FileFileDistributionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileFilesystemExporterResponseList
 */
export interface PaginatedfileFileFilesystemExporterResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileFilesystemExporterResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileFilesystemExporterResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileFilesystemExporterResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileFilesystemExporterResponse>}
     * @memberof PaginatedfileFileFilesystemExporterResponseList
     */
    results?: Array<FileFileFilesystemExporterResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFilePublicationResponseList
 */
export interface PaginatedfileFilePublicationResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFilePublicationResponse>}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    results?: Array<FileFilePublicationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileRemoteResponseList
 */
export interface PaginatedfileFileRemoteResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileRemoteResponse>}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    results?: Array<FileFileRemoteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileRepositoryResponseList
 */
export interface PaginatedfileFileRepositoryResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileRepositoryResponse>}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    results?: Array<FileFileRepositoryResponse>;
}
/**
 * Serializer for File Distributions.
 * @export
 * @interface PatchedfileFileDistribution
 */
export interface PatchedfileFileDistribution {
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    base_path?: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchedfileFileDistribution
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    name?: string;
    /**
     * Publication to be served
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    publication?: string | null;
}
/**
 * Serializer for File file system exporters.
 * @export
 * @interface PatchedfileFileFilesystemExporter
 */
export interface PatchedfileFileFilesystemExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PatchedfileFileFilesystemExporter
     */
    name?: string;
    /**
     * File system location to export to.
     * @type {string}
     * @memberof PatchedfileFileFilesystemExporter
     */
    path?: string;
}
/**
 * Serializer for File Remotes.
 * @export
 * @interface PatchedfileFileRemote
 */
export interface PatchedfileFileRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    name?: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    url?: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof PatchedfileFileRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://user:password@host:port
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    proxy_url?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchedfileFileRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    download_concurrency?: number;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof PatchedfileFileRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    rate_limit?: number | null;
}
/**
 * Serializer for File Repositories.
 * @export
 * @interface PatchedfileFileRepository
 */
export interface PatchedfileFileRepository {
    /**
     * 
     * @type {object}
     * @memberof PatchedfileFileRepository
     */
    pulp_labels?: object;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    name?: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    remote?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PolicyEnum {
    Immediate = 'immediate',
    OnDemand = 'on_demand',
    Streamed = 'streamed'
}

/**
 * Serializer for exporting publications.
 * @export
 * @interface PublicationExport
 */
export interface PublicationExport {
    /**
     * A URI of the publication to be exported.
     * @type {string}
     * @memberof PublicationExport
     */
    publication: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryAddRemoveContent
 */
export interface RepositoryAddRemoveContent {
    /**
     * A list of content units to add to a new repository version. This content is added after remove_content_units are removed.
     * @type {Array<any>}
     * @memberof RepositoryAddRemoveContent
     */
    add_content_units?: Array<any>;
    /**
     * A list of content units to remove from the latest repository version. You may also specify \'*\' as an entry to remove all content. This content is removed before add_content_units are added.
     * @type {Array<any>}
     * @memberof RepositoryAddRemoveContent
     */
    remove_content_units?: Array<any>;
    /**
     * A repository version whose content will be used as the initial set of content for the new repository version
     * @type {string}
     * @memberof RepositoryAddRemoveContent
     */
    base_version?: string;
}
/**
 * A mixin for validating unknown serializers\' fields.
 * @export
 * @interface RepositorySyncURL
 */
export interface RepositorySyncURL {
    /**
     * A remote to sync from. This will override a remote set on repository.
     * @type {string}
     * @memberof RepositorySyncURL
     */
    remote?: string;
    /**
     * If ``True``, synchronization will remove all content that is not present in the remote repository. If ``False``, sync will be additive only.
     * @type {boolean}
     * @memberof RepositorySyncURL
     */
    mirror?: boolean;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersion
 */
export interface RepositoryVersion {
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersion
     */
    base_version?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersionResponse
 */
export interface RepositoryVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryVersionResponse
     */
    number?: number;
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    base_version?: string;
    /**
     * Various count summaries of the content in the version and the HREF to view them.
     * @type {ContentSummaryResponse}
     * @memberof RepositoryVersionResponse
     */
    content_summary?: ContentSummaryResponse;
}

/**
 * ContentFilesApi - axios parameter creator
 * @export
 */
export const ContentFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a file content
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (relativePath: string, artifact?: string, file?: any, repository?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'relativePath' is not null or undefined
            if (relativePath === null || relativePath === undefined) {
                throw new RequiredError('relativePath','Required parameter relativePath was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/content/file/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


            if (artifact !== undefined) { 
                localVarFormParams.append('artifact', artifact as any);
            }
    
            if (relativePath !== undefined) { 
                localVarFormParams.append('relative_path', relativePath as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (repository !== undefined) { 
                localVarFormParams.append('repository', repository as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary List file contents
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [relativePath] relative_path
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [repositoryVersionAdded] repository_version_added
         * @param {string} [repositoryVersionRemoved] repository_version_removed
         * @param {string} [sha256] sha256
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/file/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (relativePath !== undefined) {
                localVarQueryParameter['relative_path'] = relativePath;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary Inspect a file content
         * @param {string} fileFileContentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileContentHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileContentHref' is not null or undefined
            if (fileFileContentHref === null || fileFileContentHref === undefined) {
                throw new RequiredError('fileFileContentHref','Required parameter fileFileContentHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_content_href}`
                .replace(`{${"file_file_content_href"}}`, encodeURIComponent(String(fileFileContentHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentFilesApi - functional programming interface
 * @export
 */
export const ContentFilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a file content
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await ContentFilesApiAxiosParamCreator(configuration).create(relativePath, artifact, file, repository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary List file contents
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [relativePath] relative_path
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [repositoryVersionAdded] repository_version_added
         * @param {string} [repositoryVersionRemoved] repository_version_removed
         * @param {string} [sha256] sha256
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileContentResponseList>> {
            const localVarAxiosArgs = await ContentFilesApiAxiosParamCreator(configuration).list(limit, offset, ordering, relativePath, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary Inspect a file content
         * @param {string} fileFileContentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileContentHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileContentResponse>> {
            const localVarAxiosArgs = await ContentFilesApiAxiosParamCreator(configuration).read(fileFileContentHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContentFilesApi - factory interface
 * @export
 */
export const ContentFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a file content
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return ContentFilesApiFp(configuration).create(relativePath, artifact, file, repository, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary List file contents
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [relativePath] relative_path
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [repositoryVersionAdded] repository_version_added
         * @param {string} [repositoryVersionRemoved] repository_version_removed
         * @param {string} [sha256] sha256
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileContentResponseList> {
            return ContentFilesApiFp(configuration).list(limit, offset, ordering, relativePath, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary Inspect a file content
         * @param {string} fileFileContentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileContentHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileContentResponse> {
            return ContentFilesApiFp(configuration).read(fileFileContentHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentFilesApi - object-oriented interface
 * @export
 * @class ContentFilesApi
 * @extends {BaseAPI}
 */
export class ContentFilesApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to create content,optionally create new repository version.
     * @summary Create a file content
     * @param {string} relativePath Path where the artifact is located relative to distributions base_path
     * @param {string} [artifact] Artifact file representing the physical content
     * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
     * @param {string} [repository] A URI of a repository the new content unit should be associated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFilesApi
     */
    public create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any) {
        return ContentFilesApiFp(this.configuration).create(relativePath, artifact, file, repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
     * @summary List file contents
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [relativePath] relative_path
     * @param {string} [repositoryVersion] repository_version
     * @param {string} [repositoryVersionAdded] repository_version_added
     * @param {string} [repositoryVersionRemoved] repository_version_removed
     * @param {string} [sha256] sha256
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFilesApi
     */
    public list(limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentFilesApiFp(this.configuration).list(limit, offset, ordering, relativePath, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
     * @summary Inspect a file content
     * @param {string} fileFileContentHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFilesApi
     */
    public read(fileFileContentHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentFilesApiFp(this.configuration).read(fileFileContentHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DistributionsFileApi - axios parameter creator
 * @export
 */
export const DistributionsFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileDistributionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            if (fileFileDistributionHref === null || fileFileDistributionHref === undefined) {
                throw new RequiredError('fileFileDistributionHref','Required parameter fileFileDistributionHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, encodeURIComponent(String(fileFileDistributionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a file distribution
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileDistribution: FileFileDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistribution' is not null or undefined
            if (fileFileDistribution === null || fileFileDistribution === undefined) {
                throw new RequiredError('fileFileDistribution','Required parameter fileFileDistribution was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/distributions/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileDistribution !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileDistribution !== undefined ? fileFileDistribution : {})
                : (fileFileDistribution || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary List file distributions
         * @param {string} [basePath] base_path
         * @param {string} [basePathContains] base_path__contains
         * @param {string} [basePathIcontains] base_path__icontains
         * @param {string} [basePathIn] base_path__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/distributions/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (basePath !== undefined) {
                localVarQueryParameter['base_path'] = basePath;
            }

            if (basePathContains !== undefined) {
                localVarQueryParameter['base_path__contains'] = basePathContains;
            }

            if (basePathIcontains !== undefined) {
                localVarQueryParameter['base_path__icontains'] = basePathIcontains;
            }

            if (basePathIn !== undefined) {
                localVarQueryParameter['base_path__in'] = basePathIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            if (fileFileDistributionHref === null || fileFileDistributionHref === undefined) {
                throw new RequiredError('fileFileDistributionHref','Required parameter fileFileDistributionHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedfileFileDistribution' is not null or undefined
            if (patchedfileFileDistribution === null || patchedfileFileDistribution === undefined) {
                throw new RequiredError('patchedfileFileDistribution','Required parameter patchedfileFileDistribution was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, encodeURIComponent(String(fileFileDistributionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedfileFileDistribution !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedfileFileDistribution !== undefined ? patchedfileFileDistribution : {})
                : (patchedfileFileDistribution || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary Inspect a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileDistributionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            if (fileFileDistributionHref === null || fileFileDistributionHref === undefined) {
                throw new RequiredError('fileFileDistributionHref','Required parameter fileFileDistributionHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, encodeURIComponent(String(fileFileDistributionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            if (fileFileDistributionHref === null || fileFileDistributionHref === undefined) {
                throw new RequiredError('fileFileDistributionHref','Required parameter fileFileDistributionHref was null or undefined when calling update.');
            }
            // verify required parameter 'fileFileDistribution' is not null or undefined
            if (fileFileDistribution === null || fileFileDistribution === undefined) {
                throw new RequiredError('fileFileDistribution','Required parameter fileFileDistribution was null or undefined when calling update.');
            }
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, encodeURIComponent(String(fileFileDistributionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileDistribution !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileDistribution !== undefined ? fileFileDistribution : {})
                : (fileFileDistribution || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionsFileApi - functional programming interface
 * @export
 */
export const DistributionsFileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileDistributionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await DistributionsFileApiAxiosParamCreator(configuration)._delete(fileFileDistributionHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a file distribution
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileDistribution: FileFileDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await DistributionsFileApiAxiosParamCreator(configuration).create(fileFileDistribution, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary List file distributions
         * @param {string} [basePath] base_path
         * @param {string} [basePathContains] base_path__contains
         * @param {string} [basePathIcontains] base_path__icontains
         * @param {string} [basePathIn] base_path__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileDistributionResponseList>> {
            const localVarAxiosArgs = await DistributionsFileApiAxiosParamCreator(configuration).list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await DistributionsFileApiAxiosParamCreator(configuration).partialUpdate(fileFileDistributionHref, patchedfileFileDistribution, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary Inspect a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileDistributionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileDistributionResponse>> {
            const localVarAxiosArgs = await DistributionsFileApiAxiosParamCreator(configuration).read(fileFileDistributionHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await DistributionsFileApiAxiosParamCreator(configuration).update(fileFileDistributionHref, fileFileDistribution, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DistributionsFileApi - factory interface
 * @export
 */
export const DistributionsFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileDistributionHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return DistributionsFileApiFp(configuration)._delete(fileFileDistributionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a file distribution
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileDistribution: FileFileDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return DistributionsFileApiFp(configuration).create(fileFileDistribution, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary List file distributions
         * @param {string} [basePath] base_path
         * @param {string} [basePathContains] base_path__contains
         * @param {string} [basePathIcontains] base_path__icontains
         * @param {string} [basePathIn] base_path__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileDistributionResponseList> {
            return DistributionsFileApiFp(configuration).list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return DistributionsFileApiFp(configuration).partialUpdate(fileFileDistributionHref, patchedfileFileDistribution, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary Inspect a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileDistributionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileDistributionResponse> {
            return DistributionsFileApiFp(configuration).read(fileFileDistributionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return DistributionsFileApiFp(configuration).update(fileFileDistributionHref, fileFileDistribution, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionsFileApi - object-oriented interface
 * @export
 * @class DistributionsFileApi
 * @extends {BaseAPI}
 */
export class DistributionsFileApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public _delete(fileFileDistributionHref: string, options?: any) {
        return DistributionsFileApiFp(this.configuration)._delete(fileFileDistributionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous create task
     * @summary Create a file distribution
     * @param {FileFileDistribution} fileFileDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public create(fileFileDistribution: FileFileDistribution, options?: any) {
        return DistributionsFileApiFp(this.configuration).create(fileFileDistribution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
     * @summary List file distributions
     * @param {string} [basePath] base_path
     * @param {string} [basePathContains] base_path__contains
     * @param {string} [basePathIcontains] base_path__icontains
     * @param {string} [basePathIn] base_path__in
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] pulp_label_select
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: string, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return DistributionsFileApiFp(this.configuration).list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public partialUpdate(fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options?: any) {
        return DistributionsFileApiFp(this.configuration).partialUpdate(fileFileDistributionHref, patchedfileFileDistribution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
     * @summary Inspect a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public read(fileFileDistributionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return DistributionsFileApiFp(this.configuration).read(fileFileDistributionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {FileFileDistribution} fileFileDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public update(fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options?: any) {
        return DistributionsFileApiFp(this.configuration).update(fileFileDistributionHref, fileFileDistribution, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportersFileExportsApi - axios parameter creator
 * @export
 */
export const ExportersFileExportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary Delete an export
         * @param {string} fileFilesystemExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFilesystemExportHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilesystemExportHref' is not null or undefined
            if (fileFilesystemExportHref === null || fileFilesystemExportHref === undefined) {
                throw new RequiredError('fileFilesystemExportHref','Required parameter fileFilesystemExportHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_filesystem_export_href}`
                .replace(`{${"file_filesystem_export_href"}}`, encodeURIComponent(String(fileFilesystemExportHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to export a file publication.
         * @summary Create an export
         * @param {string} fileFileFilesystemExporterHref 
         * @param {PublicationExport} publicationExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileFilesystemExporterHref: string, publicationExport: PublicationExport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporterHref' is not null or undefined
            if (fileFileFilesystemExporterHref === null || fileFileFilesystemExporterHref === undefined) {
                throw new RequiredError('fileFileFilesystemExporterHref','Required parameter fileFileFilesystemExporterHref was null or undefined when calling create.');
            }
            // verify required parameter 'publicationExport' is not null or undefined
            if (publicationExport === null || publicationExport === undefined) {
                throw new RequiredError('publicationExport','Required parameter publicationExport was null or undefined when calling create.');
            }
            const localVarPath = `{file_file_filesystem_exporter_href}exports/`
                .replace(`{${"file_file_filesystem_exporter_href"}}`, encodeURIComponent(String(fileFileFilesystemExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof publicationExport !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(publicationExport !== undefined ? publicationExport : {})
                : (publicationExport || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary List exports
         * @param {string} fileFileFilesystemExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (fileFileFilesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporterHref' is not null or undefined
            if (fileFileFilesystemExporterHref === null || fileFileFilesystemExporterHref === undefined) {
                throw new RequiredError('fileFileFilesystemExporterHref','Required parameter fileFileFilesystemExporterHref was null or undefined when calling list.');
            }
            const localVarPath = `{file_file_filesystem_exporter_href}exports/`
                .replace(`{${"file_file_filesystem_exporter_href"}}`, encodeURIComponent(String(fileFileFilesystemExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary Inspect an export
         * @param {string} fileFilesystemExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFilesystemExportHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilesystemExportHref' is not null or undefined
            if (fileFilesystemExportHref === null || fileFilesystemExportHref === undefined) {
                throw new RequiredError('fileFilesystemExportHref','Required parameter fileFilesystemExportHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_filesystem_export_href}`
                .replace(`{${"file_filesystem_export_href"}}`, encodeURIComponent(String(fileFilesystemExportHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersFileExportsApi - functional programming interface
 * @export
 */
export const ExportersFileExportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary Delete an export
         * @param {string} fileFilesystemExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFilesystemExportHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExportersFileExportsApiAxiosParamCreator(configuration)._delete(fileFilesystemExportHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to export a file publication.
         * @summary Create an export
         * @param {string} fileFileFilesystemExporterHref 
         * @param {PublicationExport} publicationExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileFilesystemExporterHref: string, publicationExport: PublicationExport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await ExportersFileExportsApiAxiosParamCreator(configuration).create(fileFileFilesystemExporterHref, publicationExport, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary List exports
         * @param {string} fileFileFilesystemExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(fileFileFilesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExportResponseList>> {
            const localVarAxiosArgs = await ExportersFileExportsApiAxiosParamCreator(configuration).list(fileFileFilesystemExporterHref, limit, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary Inspect an export
         * @param {string} fileFilesystemExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFilesystemExportHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportResponse>> {
            const localVarAxiosArgs = await ExportersFileExportsApiAxiosParamCreator(configuration).read(fileFilesystemExportHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportersFileExportsApi - factory interface
 * @export
 */
export const ExportersFileExportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary Delete an export
         * @param {string} fileFilesystemExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFilesystemExportHref: string, options?: any): AxiosPromise<void> {
            return ExportersFileExportsApiFp(configuration)._delete(fileFilesystemExportHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to export a file publication.
         * @summary Create an export
         * @param {string} fileFileFilesystemExporterHref 
         * @param {PublicationExport} publicationExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileFilesystemExporterHref: string, publicationExport: PublicationExport, options?: any): AxiosPromise<AsyncOperationResponse> {
            return ExportersFileExportsApiFp(configuration).create(fileFileFilesystemExporterHref, publicationExport, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary List exports
         * @param {string} fileFileFilesystemExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(fileFileFilesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedExportResponseList> {
            return ExportersFileExportsApiFp(configuration).list(fileFileFilesystemExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExports provide a history of previous exports.
         * @summary Inspect an export
         * @param {string} fileFilesystemExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFilesystemExportHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<ExportResponse> {
            return ExportersFileExportsApiFp(configuration).read(fileFilesystemExportHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersFileExportsApi - object-oriented interface
 * @export
 * @class ExportersFileExportsApi
 * @extends {BaseAPI}
 */
export class ExportersFileExportsApi extends BaseAPI {
    /**
     * FilesystemExports provide a history of previous exports.
     * @summary Delete an export
     * @param {string} fileFilesystemExportHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFileExportsApi
     */
    public _delete(fileFilesystemExportHref: string, options?: any) {
        return ExportersFileExportsApiFp(this.configuration)._delete(fileFilesystemExportHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to export a file publication.
     * @summary Create an export
     * @param {string} fileFileFilesystemExporterHref 
     * @param {PublicationExport} publicationExport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFileExportsApi
     */
    public create(fileFileFilesystemExporterHref: string, publicationExport: PublicationExport, options?: any) {
        return ExportersFileExportsApiFp(this.configuration).create(fileFileFilesystemExporterHref, publicationExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExports provide a history of previous exports.
     * @summary List exports
     * @param {string} fileFileFilesystemExporterHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFileExportsApi
     */
    public list(fileFileFilesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFileExportsApiFp(this.configuration).list(fileFileFilesystemExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExports provide a history of previous exports.
     * @summary Inspect an export
     * @param {string} fileFilesystemExportHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFileExportsApi
     */
    public read(fileFilesystemExportHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFileExportsApiFp(this.configuration).read(fileFilesystemExportHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportersFilesystemApi - axios parameter creator
 * @export
 */
export const ExportersFilesystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Delete a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileFilesystemExporterHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporterHref' is not null or undefined
            if (fileFileFilesystemExporterHref === null || fileFileFilesystemExporterHref === undefined) {
                throw new RequiredError('fileFileFilesystemExporterHref','Required parameter fileFileFilesystemExporterHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_file_filesystem_exporter_href}`
                .replace(`{${"file_file_filesystem_exporter_href"}}`, encodeURIComponent(String(fileFileFilesystemExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Create a file filesystem exporter
         * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileFilesystemExporter: FileFileFilesystemExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporter' is not null or undefined
            if (fileFileFilesystemExporter === null || fileFileFilesystemExporter === undefined) {
                throw new RequiredError('fileFileFilesystemExporter','Required parameter fileFileFilesystemExporter was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/exporters/file/filesystem/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileFilesystemExporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileFilesystemExporter !== undefined ? fileFileFilesystemExporter : {})
                : (fileFileFilesystemExporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary List file filesystem exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/exporters/file/filesystem/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Update a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {PatchedfileFileFilesystemExporter} patchedfileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileFilesystemExporterHref: string, patchedfileFileFilesystemExporter: PatchedfileFileFilesystemExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporterHref' is not null or undefined
            if (fileFileFilesystemExporterHref === null || fileFileFilesystemExporterHref === undefined) {
                throw new RequiredError('fileFileFilesystemExporterHref','Required parameter fileFileFilesystemExporterHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedfileFileFilesystemExporter' is not null or undefined
            if (patchedfileFileFilesystemExporter === null || patchedfileFileFilesystemExporter === undefined) {
                throw new RequiredError('patchedfileFileFilesystemExporter','Required parameter patchedfileFileFilesystemExporter was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{file_file_filesystem_exporter_href}`
                .replace(`{${"file_file_filesystem_exporter_href"}}`, encodeURIComponent(String(fileFileFilesystemExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedfileFileFilesystemExporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedfileFileFilesystemExporter !== undefined ? patchedfileFileFilesystemExporter : {})
                : (patchedfileFileFilesystemExporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Inspect a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileFilesystemExporterHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporterHref' is not null or undefined
            if (fileFileFilesystemExporterHref === null || fileFileFilesystemExporterHref === undefined) {
                throw new RequiredError('fileFileFilesystemExporterHref','Required parameter fileFileFilesystemExporterHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_filesystem_exporter_href}`
                .replace(`{${"file_file_filesystem_exporter_href"}}`, encodeURIComponent(String(fileFileFilesystemExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Update a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileFilesystemExporterHref: string, fileFileFilesystemExporter: FileFileFilesystemExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileFilesystemExporterHref' is not null or undefined
            if (fileFileFilesystemExporterHref === null || fileFileFilesystemExporterHref === undefined) {
                throw new RequiredError('fileFileFilesystemExporterHref','Required parameter fileFileFilesystemExporterHref was null or undefined when calling update.');
            }
            // verify required parameter 'fileFileFilesystemExporter' is not null or undefined
            if (fileFileFilesystemExporter === null || fileFileFilesystemExporter === undefined) {
                throw new RequiredError('fileFileFilesystemExporter','Required parameter fileFileFilesystemExporter was null or undefined when calling update.');
            }
            const localVarPath = `{file_file_filesystem_exporter_href}`
                .replace(`{${"file_file_filesystem_exporter_href"}}`, encodeURIComponent(String(fileFileFilesystemExporterHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileFilesystemExporter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileFilesystemExporter !== undefined ? fileFileFilesystemExporter : {})
                : (fileFileFilesystemExporter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersFilesystemApi - functional programming interface
 * @export
 */
export const ExportersFilesystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Delete a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileFilesystemExporterHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExportersFilesystemApiAxiosParamCreator(configuration)._delete(fileFileFilesystemExporterHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Create a file filesystem exporter
         * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileFilesystemExporter: FileFileFilesystemExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileFilesystemExporterResponse>> {
            const localVarAxiosArgs = await ExportersFilesystemApiAxiosParamCreator(configuration).create(fileFileFilesystemExporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary List file filesystem exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileFilesystemExporterResponseList>> {
            const localVarAxiosArgs = await ExportersFilesystemApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Update a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {PatchedfileFileFilesystemExporter} patchedfileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileFilesystemExporterHref: string, patchedfileFileFilesystemExporter: PatchedfileFileFilesystemExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileFilesystemExporterResponse>> {
            const localVarAxiosArgs = await ExportersFilesystemApiAxiosParamCreator(configuration).partialUpdate(fileFileFilesystemExporterHref, patchedfileFileFilesystemExporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Inspect a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileFilesystemExporterHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileFilesystemExporterResponse>> {
            const localVarAxiosArgs = await ExportersFilesystemApiAxiosParamCreator(configuration).read(fileFileFilesystemExporterHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Update a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileFilesystemExporterHref: string, fileFileFilesystemExporter: FileFileFilesystemExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileFilesystemExporterResponse>> {
            const localVarAxiosArgs = await ExportersFilesystemApiAxiosParamCreator(configuration).update(fileFileFilesystemExporterHref, fileFileFilesystemExporter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportersFilesystemApi - factory interface
 * @export
 */
export const ExportersFilesystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Delete a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileFilesystemExporterHref: string, options?: any): AxiosPromise<void> {
            return ExportersFilesystemApiFp(configuration)._delete(fileFileFilesystemExporterHref, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Create a file filesystem exporter
         * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileFilesystemExporter: FileFileFilesystemExporter, options?: any): AxiosPromise<FileFileFilesystemExporterResponse> {
            return ExportersFilesystemApiFp(configuration).create(fileFileFilesystemExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary List file filesystem exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileFilesystemExporterResponseList> {
            return ExportersFilesystemApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Update a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {PatchedfileFileFilesystemExporter} patchedfileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileFilesystemExporterHref: string, patchedfileFileFilesystemExporter: PatchedfileFileFilesystemExporter, options?: any): AxiosPromise<FileFileFilesystemExporterResponse> {
            return ExportersFilesystemApiFp(configuration).partialUpdate(fileFileFilesystemExporterHref, patchedfileFileFilesystemExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Inspect a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileFilesystemExporterHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileFilesystemExporterResponse> {
            return ExportersFilesystemApiFp(configuration).read(fileFileFilesystemExporterHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
         * @summary Update a file filesystem exporter
         * @param {string} fileFileFilesystemExporterHref 
         * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileFilesystemExporterHref: string, fileFileFilesystemExporter: FileFileFilesystemExporter, options?: any): AxiosPromise<FileFileFilesystemExporterResponse> {
            return ExportersFilesystemApiFp(configuration).update(fileFileFilesystemExporterHref, fileFileFilesystemExporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersFilesystemApi - object-oriented interface
 * @export
 * @class ExportersFilesystemApi
 * @extends {BaseAPI}
 */
export class ExportersFilesystemApi extends BaseAPI {
    /**
     * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
     * @summary Delete a file filesystem exporter
     * @param {string} fileFileFilesystemExporterHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public _delete(fileFileFilesystemExporterHref: string, options?: any) {
        return ExportersFilesystemApiFp(this.configuration)._delete(fileFileFilesystemExporterHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
     * @summary Create a file filesystem exporter
     * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public create(fileFileFilesystemExporter: FileFileFilesystemExporter, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).create(fileFileFilesystemExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
     * @summary List file filesystem exporters
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
     * @summary Update a file filesystem exporter
     * @param {string} fileFileFilesystemExporterHref 
     * @param {PatchedfileFileFilesystemExporter} patchedfileFileFilesystemExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public partialUpdate(fileFileFilesystemExporterHref: string, patchedfileFileFilesystemExporter: PatchedfileFileFilesystemExporter, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).partialUpdate(fileFileFilesystemExporterHref, patchedfileFileFilesystemExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
     * @summary Inspect a file filesystem exporter
     * @param {string} fileFileFilesystemExporterHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public read(fileFileFilesystemExporterHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).read(fileFileFilesystemExporterHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * FilesystemExporters export content from a publication to a path on the file system.  WARNING: This feature is provided as a tech preview and may change in the future. Backwards compatibility is not guaranteed.
     * @summary Update a file filesystem exporter
     * @param {string} fileFileFilesystemExporterHref 
     * @param {FileFileFilesystemExporter} fileFileFilesystemExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public update(fileFileFilesystemExporterHref: string, fileFileFilesystemExporter: FileFileFilesystemExporter, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).update(fileFileFilesystemExporterHref, fileFileFilesystemExporter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicationsFileApi - axios parameter creator
 * @export
 */
export const PublicationsFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Delete a file publication
         * @param {string} fileFilePublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFilePublicationHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilePublicationHref' is not null or undefined
            if (fileFilePublicationHref === null || fileFilePublicationHref === undefined) {
                throw new RequiredError('fileFilePublicationHref','Required parameter fileFilePublicationHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_file_publication_href}`
                .replace(`{${"file_file_publication_href"}}`, encodeURIComponent(String(fileFilePublicationHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to publish file content.
         * @summary Create a file publication
         * @param {FileFilePublication} fileFilePublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFilePublication: FileFilePublication, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilePublication' is not null or undefined
            if (fileFilePublication === null || fileFilePublication === undefined) {
                throw new RequiredError('fileFilePublication','Required parameter fileFilePublication was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/publications/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFilePublication !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFilePublication !== undefined ? fileFilePublication : {})
                : (fileFilePublication || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary List file publications
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] pulp_created
         * @param {string} [pulpCreatedGt] pulp_created__gt
         * @param {string} [pulpCreatedGte] pulp_created__gte
         * @param {string} [pulpCreatedLt] pulp_created__lt
         * @param {string} [pulpCreatedLte] pulp_created__lte
         * @param {string} [pulpCreatedRange] pulp_created__range
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, repositoryVersion?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/publications/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = pulpCreatedLte;
            }

            if (pulpCreatedRange !== undefined) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Inspect a file publication
         * @param {string} fileFilePublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFilePublicationHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilePublicationHref' is not null or undefined
            if (fileFilePublicationHref === null || fileFilePublicationHref === undefined) {
                throw new RequiredError('fileFilePublicationHref','Required parameter fileFilePublicationHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_publication_href}`
                .replace(`{${"file_file_publication_href"}}`, encodeURIComponent(String(fileFilePublicationHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationsFileApi - functional programming interface
 * @export
 */
export const PublicationsFileApiFp = function(configuration?: Configuration) {
    return {
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Delete a file publication
         * @param {string} fileFilePublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFilePublicationHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PublicationsFileApiAxiosParamCreator(configuration)._delete(fileFilePublicationHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to publish file content.
         * @summary Create a file publication
         * @param {FileFilePublication} fileFilePublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFilePublication: FileFilePublication, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await PublicationsFileApiAxiosParamCreator(configuration).create(fileFilePublication, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary List file publications
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] pulp_created
         * @param {string} [pulpCreatedGt] pulp_created__gt
         * @param {string} [pulpCreatedGte] pulp_created__gte
         * @param {string} [pulpCreatedLt] pulp_created__lt
         * @param {string} [pulpCreatedLte] pulp_created__lte
         * @param {string} [pulpCreatedRange] pulp_created__range
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFilePublicationResponseList>> {
            const localVarAxiosArgs = await PublicationsFileApiAxiosParamCreator(configuration).list(limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Inspect a file publication
         * @param {string} fileFilePublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFilePublicationHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFilePublicationResponse>> {
            const localVarAxiosArgs = await PublicationsFileApiAxiosParamCreator(configuration).read(fileFilePublicationHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PublicationsFileApi - factory interface
 * @export
 */
export const PublicationsFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Delete a file publication
         * @param {string} fileFilePublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFilePublicationHref: string, options?: any): AxiosPromise<void> {
            return PublicationsFileApiFp(configuration)._delete(fileFilePublicationHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to publish file content.
         * @summary Create a file publication
         * @param {FileFilePublication} fileFilePublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFilePublication: FileFilePublication, options?: any): AxiosPromise<AsyncOperationResponse> {
            return PublicationsFileApiFp(configuration).create(fileFilePublication, options).then((request) => request(axios, basePath));
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary List file publications
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] pulp_created
         * @param {string} [pulpCreatedGt] pulp_created__gt
         * @param {string} [pulpCreatedGte] pulp_created__gte
         * @param {string} [pulpCreatedLt] pulp_created__lt
         * @param {string} [pulpCreatedLte] pulp_created__lte
         * @param {string} [pulpCreatedRange] pulp_created__range
         * @param {string} [repositoryVersion] repository_version
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFilePublicationResponseList> {
            return PublicationsFileApiFp(configuration).list(limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Inspect a file publication
         * @param {string} fileFilePublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFilePublicationHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFilePublicationResponse> {
            return PublicationsFileApiFp(configuration).read(fileFilePublicationHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicationsFileApi - object-oriented interface
 * @export
 * @class PublicationsFileApi
 * @extends {BaseAPI}
 */
export class PublicationsFileApi extends BaseAPI {
    /**
     *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
     * @summary Delete a file publication
     * @param {string} fileFilePublicationHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public _delete(fileFilePublicationHref: string, options?: any) {
        return PublicationsFileApiFp(this.configuration)._delete(fileFilePublicationHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to publish file content.
     * @summary Create a file publication
     * @param {FileFilePublication} fileFilePublication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public create(fileFilePublication: FileFilePublication, options?: any) {
        return PublicationsFileApiFp(this.configuration).create(fileFilePublication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
     * @summary List file publications
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] pulp_created
     * @param {string} [pulpCreatedGt] pulp_created__gt
     * @param {string} [pulpCreatedGte] pulp_created__gte
     * @param {string} [pulpCreatedLt] pulp_created__lt
     * @param {string} [pulpCreatedLte] pulp_created__lte
     * @param {string} [pulpCreatedRange] pulp_created__range
     * @param {string} [repositoryVersion] repository_version
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public list(limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsFileApiFp(this.configuration).list(limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
     * @summary Inspect a file publication
     * @param {string} fileFilePublicationHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public read(fileFilePublicationHref: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsFileApiFp(this.configuration).read(fileFilePublicationHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemotesFileApi - axios parameter creator
 * @export
 */
export const RemotesFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file remote
         * @param {string} fileFileRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileRemoteHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            if (fileFileRemoteHref === null || fileFileRemoteHref === undefined) {
                throw new RequiredError('fileFileRemoteHref','Required parameter fileFileRemoteHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, encodeURIComponent(String(fileFileRemoteHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Create a file remote
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileRemote: FileFileRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemote' is not null or undefined
            if (fileFileRemote === null || fileFileRemote === undefined) {
                throw new RequiredError('fileFileRemote','Required parameter fileFileRemote was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/remotes/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileRemote !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileRemote !== undefined ? fileFileRemote : {})
                : (fileFileRemote || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary List file remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [pulpLastUpdated] pulp_last_updated
         * @param {string} [pulpLastUpdatedGt] pulp_last_updated__gt
         * @param {string} [pulpLastUpdatedGte] pulp_last_updated__gte
         * @param {string} [pulpLastUpdatedLt] pulp_last_updated__lt
         * @param {string} [pulpLastUpdatedLte] pulp_last_updated__lte
         * @param {string} [pulpLastUpdatedRange] pulp_last_updated__range
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/remotes/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (pulpLastUpdated !== undefined) {
                localVarQueryParameter['pulp_last_updated'] = pulpLastUpdated;
            }

            if (pulpLastUpdatedGt !== undefined) {
                localVarQueryParameter['pulp_last_updated__gt'] = pulpLastUpdatedGt;
            }

            if (pulpLastUpdatedGte !== undefined) {
                localVarQueryParameter['pulp_last_updated__gte'] = pulpLastUpdatedGte;
            }

            if (pulpLastUpdatedLt !== undefined) {
                localVarQueryParameter['pulp_last_updated__lt'] = pulpLastUpdatedLt;
            }

            if (pulpLastUpdatedLte !== undefined) {
                localVarQueryParameter['pulp_last_updated__lte'] = pulpLastUpdatedLte;
            }

            if (pulpLastUpdatedRange !== undefined) {
                localVarQueryParameter['pulp_last_updated__range'] = pulpLastUpdatedRange;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {PatchedfileFileRemote} patchedfileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            if (fileFileRemoteHref === null || fileFileRemoteHref === undefined) {
                throw new RequiredError('fileFileRemoteHref','Required parameter fileFileRemoteHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedfileFileRemote' is not null or undefined
            if (patchedfileFileRemote === null || patchedfileFileRemote === undefined) {
                throw new RequiredError('patchedfileFileRemote','Required parameter patchedfileFileRemote was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, encodeURIComponent(String(fileFileRemoteHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedfileFileRemote !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedfileFileRemote !== undefined ? patchedfileFileRemote : {})
                : (patchedfileFileRemote || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Inspect a file remote
         * @param {string} fileFileRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileRemoteHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            if (fileFileRemoteHref === null || fileFileRemoteHref === undefined) {
                throw new RequiredError('fileFileRemoteHref','Required parameter fileFileRemoteHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, encodeURIComponent(String(fileFileRemoteHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            if (fileFileRemoteHref === null || fileFileRemoteHref === undefined) {
                throw new RequiredError('fileFileRemoteHref','Required parameter fileFileRemoteHref was null or undefined when calling update.');
            }
            // verify required parameter 'fileFileRemote' is not null or undefined
            if (fileFileRemote === null || fileFileRemote === undefined) {
                throw new RequiredError('fileFileRemote','Required parameter fileFileRemote was null or undefined when calling update.');
            }
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, encodeURIComponent(String(fileFileRemoteHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileRemote !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileRemote !== undefined ? fileFileRemote : {})
                : (fileFileRemote || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemotesFileApi - functional programming interface
 * @export
 */
export const RemotesFileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file remote
         * @param {string} fileFileRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileRemoteHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RemotesFileApiAxiosParamCreator(configuration)._delete(fileFileRemoteHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Create a file remote
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileRemote: FileFileRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRemoteResponse>> {
            const localVarAxiosArgs = await RemotesFileApiAxiosParamCreator(configuration).create(fileFileRemote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary List file remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [pulpLastUpdated] pulp_last_updated
         * @param {string} [pulpLastUpdatedGt] pulp_last_updated__gt
         * @param {string} [pulpLastUpdatedGte] pulp_last_updated__gte
         * @param {string} [pulpLastUpdatedLt] pulp_last_updated__lt
         * @param {string} [pulpLastUpdatedLte] pulp_last_updated__lte
         * @param {string} [pulpLastUpdatedRange] pulp_last_updated__range
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileRemoteResponseList>> {
            const localVarAxiosArgs = await RemotesFileApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {PatchedfileFileRemote} patchedfileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RemotesFileApiAxiosParamCreator(configuration).partialUpdate(fileFileRemoteHref, patchedfileFileRemote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Inspect a file remote
         * @param {string} fileFileRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileRemoteHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRemoteResponse>> {
            const localVarAxiosArgs = await RemotesFileApiAxiosParamCreator(configuration).read(fileFileRemoteHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RemotesFileApiAxiosParamCreator(configuration).update(fileFileRemoteHref, fileFileRemote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemotesFileApi - factory interface
 * @export
 */
export const RemotesFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file remote
         * @param {string} fileFileRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileRemoteHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RemotesFileApiFp(configuration)._delete(fileFileRemoteHref, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Create a file remote
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileRemote: FileFileRemote, options?: any): AxiosPromise<FileFileRemoteResponse> {
            return RemotesFileApiFp(configuration).create(fileFileRemote, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary List file remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [pulpLastUpdated] pulp_last_updated
         * @param {string} [pulpLastUpdatedGt] pulp_last_updated__gt
         * @param {string} [pulpLastUpdatedGte] pulp_last_updated__gte
         * @param {string} [pulpLastUpdatedLt] pulp_last_updated__lt
         * @param {string} [pulpLastUpdatedLte] pulp_last_updated__lte
         * @param {string} [pulpLastUpdatedRange] pulp_last_updated__range
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileRemoteResponseList> {
            return RemotesFileApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {PatchedfileFileRemote} patchedfileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RemotesFileApiFp(configuration).partialUpdate(fileFileRemoteHref, patchedfileFileRemote, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Inspect a file remote
         * @param {string} fileFileRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileRemoteHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileRemoteResponse> {
            return RemotesFileApiFp(configuration).read(fileFileRemoteHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RemotesFileApiFp(configuration).update(fileFileRemoteHref, fileFileRemote, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemotesFileApi - object-oriented interface
 * @export
 * @class RemotesFileApi
 * @extends {BaseAPI}
 */
export class RemotesFileApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a file remote
     * @param {string} fileFileRemoteHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public _delete(fileFileRemoteHref: string, options?: any) {
        return RemotesFileApiFp(this.configuration)._delete(fileFileRemoteHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
     * @summary Create a file remote
     * @param {FileFileRemote} fileFileRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public create(fileFileRemote: FileFileRemote, options?: any) {
        return RemotesFileApiFp(this.configuration).create(fileFileRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
     * @summary List file remotes
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] pulp_label_select
     * @param {string} [pulpLastUpdated] pulp_last_updated
     * @param {string} [pulpLastUpdatedGt] pulp_last_updated__gt
     * @param {string} [pulpLastUpdatedGte] pulp_last_updated__gte
     * @param {string} [pulpLastUpdatedLt] pulp_last_updated__lt
     * @param {string} [pulpLastUpdatedLte] pulp_last_updated__lte
     * @param {string} [pulpLastUpdatedRange] pulp_last_updated__range
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: string, fields?: string, excludeFields?: string, options?: any) {
        return RemotesFileApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a file remote
     * @param {string} fileFileRemoteHref 
     * @param {PatchedfileFileRemote} patchedfileFileRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public partialUpdate(fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options?: any) {
        return RemotesFileApiFp(this.configuration).partialUpdate(fileFileRemoteHref, patchedfileFileRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
     * @summary Inspect a file remote
     * @param {string} fileFileRemoteHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public read(fileFileRemoteHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RemotesFileApiFp(this.configuration).read(fileFileRemoteHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a file remote
     * @param {string} fileFileRemoteHref 
     * @param {FileFileRemote} fileFileRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public update(fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options?: any) {
        return RemotesFileApiFp(this.configuration).update(fileFileRemoteHref, fileFileRemote, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoriesFileApi - axios parameter creator
 * @export
 */
export const RepositoriesFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileRepositoryHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, encodeURIComponent(String(fileFileRepositoryHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Create a file repository
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileRepository: FileFileRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepository' is not null or undefined
            if (fileFileRepository === null || fileFileRepository === undefined) {
                throw new RequiredError('fileFileRepository','Required parameter fileFileRepository was null or undefined when calling create.');
            }
            const localVarPath = `/pulp/api/v3/repositories/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileRepository !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileRepository !== undefined ? fileFileRepository : {})
                : (fileFileRepository || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary List file repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repositories/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn !== undefined) {
                localVarQueryParameter['name__in'] = nameIn;
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} fileFileRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modify: async (fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling modify.');
            }
            // verify required parameter 'repositoryAddRemoveContent' is not null or undefined
            if (repositoryAddRemoveContent === null || repositoryAddRemoveContent === undefined) {
                throw new RequiredError('repositoryAddRemoveContent','Required parameter repositoryAddRemoveContent was null or undefined when calling modify.');
            }
            const localVarPath = `{file_file_repository_href}modify/`
                .replace(`{${"file_file_repository_href"}}`, encodeURIComponent(String(fileFileRepositoryHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof repositoryAddRemoveContent !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(repositoryAddRemoveContent !== undefined ? repositoryAddRemoveContent : {})
                : (repositoryAddRemoveContent || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {PatchedfileFileRepository} patchedfileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling partialUpdate.');
            }
            // verify required parameter 'patchedfileFileRepository' is not null or undefined
            if (patchedfileFileRepository === null || patchedfileFileRepository === undefined) {
                throw new RequiredError('patchedfileFileRepository','Required parameter patchedfileFileRepository was null or undefined when calling partialUpdate.');
            }
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, encodeURIComponent(String(fileFileRepositoryHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedfileFileRepository !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedfileFileRepository !== undefined ? patchedfileFileRepository : {})
                : (patchedfileFileRepository || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Inspect a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, encodeURIComponent(String(fileFileRepositoryHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to sync file content.
         * @param {string} fileFileRepositoryHref 
         * @param {RepositorySyncURL} repositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync: async (fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling sync.');
            }
            // verify required parameter 'repositorySyncURL' is not null or undefined
            if (repositorySyncURL === null || repositorySyncURL === undefined) {
                throw new RequiredError('repositorySyncURL','Required parameter repositorySyncURL was null or undefined when calling sync.');
            }

            // removing encodeURIComponent by hand since fileFileRepositoryHref should not be encoded
            const localVarPath = `{file_file_repository_href}sync/`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof repositorySyncURL !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(repositorySyncURL !== undefined ? repositorySyncURL : {})
                : (repositorySyncURL || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling update.');
            }
            // verify required parameter 'fileFileRepository' is not null or undefined
            if (fileFileRepository === null || fileFileRepository === undefined) {
                throw new RequiredError('fileFileRepository','Required parameter fileFileRepository was null or undefined when calling update.');
            }
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, encodeURIComponent(String(fileFileRepositoryHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileFileRepository !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileFileRepository !== undefined ? fileFileRepository : {})
                : (fileFileRepository || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesFileApi - functional programming interface
 * @export
 */
export const RepositoriesFileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileRepositoryHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration)._delete(fileFileRepositoryHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Create a file repository
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileRepository: FileFileRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRepositoryResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).create(fileFileRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary List file repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileRepositoryResponseList>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} fileFileRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modify(fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).modify(fileFileRepositoryHref, repositoryAddRemoveContent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {PatchedfileFileRepository} patchedfileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).partialUpdate(fileFileRepositoryHref, patchedfileFileRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Inspect a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRepositoryResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).read(fileFileRepositoryHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to sync file content.
         * @param {string} fileFileRepositoryHref 
         * @param {RepositorySyncURL} repositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sync(fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).sync(fileFileRepositoryHref, repositorySyncURL, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileApiAxiosParamCreator(configuration).update(fileFileRepositoryHref, fileFileRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepositoriesFileApi - factory interface
 * @export
 */
export const RepositoriesFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileRepositoryHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileApiFp(configuration)._delete(fileFileRepositoryHref, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Create a file repository
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileRepository: FileFileRepository, options?: any): AxiosPromise<FileFileRepositoryResponse> {
            return RepositoriesFileApiFp(configuration).create(fileFileRepository, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary List file repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] name
         * @param {string} [nameContains] name__contains
         * @param {string} [nameIcontains] name__icontains
         * @param {string} [nameIn] name__in
         * @param {string} [nameStartswith] name__startswith
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] pulp_label_select
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileRepositoryResponseList> {
            return RepositoriesFileApiFp(configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} fileFileRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modify(fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileApiFp(configuration).modify(fileFileRepositoryHref, repositoryAddRemoveContent, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {PatchedfileFileRepository} patchedfileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileApiFp(configuration).partialUpdate(fileFileRepositoryHref, patchedfileFileRepository, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Inspect a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileRepositoryResponse> {
            return RepositoriesFileApiFp(configuration).read(fileFileRepositoryHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to sync file content.
         * @param {string} fileFileRepositoryHref 
         * @param {RepositorySyncURL} repositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync(fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileApiFp(configuration).sync(fileFileRepositoryHref, repositorySyncURL, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileApiFp(configuration).update(fileFileRepositoryHref, fileFileRepository, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesFileApi - object-oriented interface
 * @export
 * @class RepositoriesFileApi
 * @extends {BaseAPI}
 */
export class RepositoriesFileApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public _delete(fileFileRepositoryHref: string, options?: any) {
        return RepositoriesFileApiFp(this.configuration)._delete(fileFileRepositoryHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
     * @summary Create a file repository
     * @param {FileFileRepository} fileFileRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public create(fileFileRepository: FileFileRepository, options?: any) {
        return RepositoriesFileApiFp(this.configuration).create(fileFileRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
     * @summary List file repositorys
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] name
     * @param {string} [nameContains] name__contains
     * @param {string} [nameIcontains] name__icontains
     * @param {string} [nameIn] name__in
     * @param {string} [nameStartswith] name__startswith
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] pulp_label_select
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: string, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to create a new repository version.
     * @summary Modify Repository Content
     * @param {string} fileFileRepositoryHref 
     * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public modify(fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any) {
        return RepositoriesFileApiFp(this.configuration).modify(fileFileRepositoryHref, repositoryAddRemoveContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {PatchedfileFileRepository} patchedfileFileRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public partialUpdate(fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options?: any) {
        return RepositoriesFileApiFp(this.configuration).partialUpdate(fileFileRepositoryHref, patchedfileFileRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
     * @summary Inspect a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public read(fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileApiFp(this.configuration).read(fileFileRepositoryHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to sync file content.
     * @param {string} fileFileRepositoryHref 
     * @param {RepositorySyncURL} repositorySyncURL 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public sync(fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options?: any) {
        return RepositoriesFileApiFp(this.configuration).sync(fileFileRepositoryHref, repositorySyncURL, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {FileFileRepository} fileFileRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public update(fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options?: any) {
        return RepositoriesFileApiFp(this.configuration).update(fileFileRepositoryHref, fileFileRepository, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoriesFileVersionsApi - axios parameter creator
 * @export
 */
export const RepositoriesFileVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileRepositoryVersionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryVersionHref' is not null or undefined
            if (fileFileRepositoryVersionHref === null || fileFileRepositoryVersionHref === undefined) {
                throw new RequiredError('fileFileRepositoryVersionHref','Required parameter fileFileRepositoryVersionHref was null or undefined when calling _delete.');
            }
            const localVarPath = `{file_file_repository_version_href}`
                .replace(`{${"file_file_repository_version_href"}}`, encodeURIComponent(String(fileFileRepositoryVersionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary List repository versions
         * @param {string} fileFileRepositoryHref 
         * @param {string} [content] content
         * @param {string} [contentIn] content__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [number] number
         * @param {string} [numberGt] number__gt
         * @param {string} [numberGte] number__gte
         * @param {string} [numberLt] number__lt
         * @param {string} [numberLte] number__lte
         * @param {string} [numberRange] number__range
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] pulp_created
         * @param {string} [pulpCreatedGt] pulp_created__gt
         * @param {string} [pulpCreatedGte] pulp_created__gte
         * @param {string} [pulpCreatedLt] pulp_created__lt
         * @param {string} [pulpCreatedLte] pulp_created__lte
         * @param {string} [pulpCreatedRange] pulp_created__range
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: string, numberGt?: string, numberGte?: string, numberLt?: string, numberLte?: string, numberRange?: string, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            if (fileFileRepositoryHref === null || fileFileRepositoryHref === undefined) {
                throw new RequiredError('fileFileRepositoryHref','Required parameter fileFileRepositoryHref was null or undefined when calling list.');
            }
            const localVarPath = `{file_file_repository_href}versions/`
                .replace(`{${"file_file_repository_href"}}`, encodeURIComponent(String(fileFileRepositoryHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (numberGt !== undefined) {
                localVarQueryParameter['number__gt'] = numberGt;
            }

            if (numberGte !== undefined) {
                localVarQueryParameter['number__gte'] = numberGte;
            }

            if (numberLt !== undefined) {
                localVarQueryParameter['number__lt'] = numberLt;
            }

            if (numberLte !== undefined) {
                localVarQueryParameter['number__lte'] = numberLte;
            }

            if (numberRange !== undefined) {
                localVarQueryParameter['number__range'] = numberRange;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = pulpCreatedLte;
            }

            if (pulpCreatedRange !== undefined) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary Inspect a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryVersionHref' is not null or undefined
            if (fileFileRepositoryVersionHref === null || fileFileRepositoryVersionHref === undefined) {
                throw new RequiredError('fileFileRepositoryVersionHref','Required parameter fileFileRepositoryVersionHref was null or undefined when calling read.');
            }
            const localVarPath = `{file_file_repository_version_href}`
                .replace(`{${"file_file_repository_version_href"}}`, encodeURIComponent(String(fileFileRepositoryVersionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} fileFileRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repair: async (fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryVersionHref' is not null or undefined
            if (fileFileRepositoryVersionHref === null || fileFileRepositoryVersionHref === undefined) {
                throw new RequiredError('fileFileRepositoryVersionHref','Required parameter fileFileRepositoryVersionHref was null or undefined when calling repair.');
            }
            // verify required parameter 'repositoryVersion' is not null or undefined
            if (repositoryVersion === null || repositoryVersion === undefined) {
                throw new RequiredError('repositoryVersion','Required parameter repositoryVersion was null or undefined when calling repair.');
            }
            const localVarPath = `{file_file_repository_version_href}repair/`
                .replace(`{${"file_file_repository_version_href"}}`, encodeURIComponent(String(fileFileRepositoryVersionHref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof repositoryVersion !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(repositoryVersion !== undefined ? repositoryVersion : {})
                : (repositoryVersion || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesFileVersionsApi - functional programming interface
 * @export
 */
export const RepositoriesFileVersionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileRepositoryVersionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileVersionsApiAxiosParamCreator(configuration)._delete(fileFileRepositoryVersionHref, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary List repository versions
         * @param {string} fileFileRepositoryHref 
         * @param {string} [content] content
         * @param {string} [contentIn] content__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [number] number
         * @param {string} [numberGt] number__gt
         * @param {string} [numberGte] number__gte
         * @param {string} [numberLt] number__lt
         * @param {string} [numberLte] number__lte
         * @param {string} [numberRange] number__range
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] pulp_created
         * @param {string} [pulpCreatedGt] pulp_created__gt
         * @param {string} [pulpCreatedGte] pulp_created__gte
         * @param {string} [pulpCreatedLt] pulp_created__lt
         * @param {string} [pulpCreatedLte] pulp_created__lte
         * @param {string} [pulpCreatedRange] pulp_created__range
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: string, numberGt?: string, numberGte?: string, numberLt?: string, numberLte?: string, numberRange?: string, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryVersionResponseList>> {
            const localVarAxiosArgs = await RepositoriesFileVersionsApiAxiosParamCreator(configuration).list(fileFileRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary Inspect a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryVersionResponse>> {
            const localVarAxiosArgs = await RepositoriesFileVersionsApiAxiosParamCreator(configuration).read(fileFileRepositoryVersionHref, fields, excludeFields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} fileFileRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repair(fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await RepositoriesFileVersionsApiAxiosParamCreator(configuration).repair(fileFileRepositoryVersionHref, repositoryVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RepositoriesFileVersionsApi - factory interface
 * @export
 */
export const RepositoriesFileVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileRepositoryVersionHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileVersionsApiFp(configuration)._delete(fileFileRepositoryVersionHref, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary List repository versions
         * @param {string} fileFileRepositoryHref 
         * @param {string} [content] content
         * @param {string} [contentIn] content__in
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [number] number
         * @param {string} [numberGt] number__gt
         * @param {string} [numberGte] number__gte
         * @param {string} [numberLt] number__lt
         * @param {string} [numberLte] number__lte
         * @param {string} [numberRange] number__range
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] pulp_created
         * @param {string} [pulpCreatedGt] pulp_created__gt
         * @param {string} [pulpCreatedGte] pulp_created__gte
         * @param {string} [pulpCreatedLt] pulp_created__lt
         * @param {string} [pulpCreatedLte] pulp_created__lte
         * @param {string} [pulpCreatedRange] pulp_created__range
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: string, numberGt?: string, numberGte?: string, numberLt?: string, numberLte?: string, numberRange?: string, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRepositoryVersionResponseList> {
            return RepositoriesFileVersionsApiFp(configuration).list(fileFileRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary Inspect a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RepositoryVersionResponse> {
            return RepositoriesFileVersionsApiFp(configuration).read(fileFileRepositoryVersionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} fileFileRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repair(fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any): AxiosPromise<AsyncOperationResponse> {
            return RepositoriesFileVersionsApiFp(configuration).repair(fileFileRepositoryVersionHref, repositoryVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesFileVersionsApi - object-oriented interface
 * @export
 * @class RepositoriesFileVersionsApi
 * @extends {BaseAPI}
 */
export class RepositoriesFileVersionsApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to delete a repository version.
     * @summary Delete a repository version
     * @param {string} fileFileRepositoryVersionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public _delete(fileFileRepositoryVersionHref: string, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration)._delete(fileFileRepositoryVersionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepositoryVersion represents a single file repository version.
     * @summary List repository versions
     * @param {string} fileFileRepositoryHref 
     * @param {string} [content] content
     * @param {string} [contentIn] content__in
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [number] number
     * @param {string} [numberGt] number__gt
     * @param {string} [numberGte] number__gte
     * @param {string} [numberLt] number__lt
     * @param {string} [numberLte] number__lte
     * @param {string} [numberRange] number__range
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] pulp_created
     * @param {string} [pulpCreatedGt] pulp_created__gt
     * @param {string} [pulpCreatedGte] pulp_created__gte
     * @param {string} [pulpCreatedLt] pulp_created__lt
     * @param {string} [pulpCreatedLte] pulp_created__lte
     * @param {string} [pulpCreatedRange] pulp_created__range
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public list(fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: string, numberGt?: string, numberGte?: string, numberLt?: string, numberLte?: string, numberRange?: string, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration).list(fileFileRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepositoryVersion represents a single file repository version.
     * @summary Inspect a repository version
     * @param {string} fileFileRepositoryVersionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public read(fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration).read(fileFileRepositoryVersionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to repair a repository version.
     * @param {string} fileFileRepositoryVersionHref 
     * @param {RepositoryVersion} repositoryVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public repair(fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration).repair(fileFileRepositoryVersionHref, repositoryVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


